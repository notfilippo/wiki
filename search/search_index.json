{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"E-Agle TRT Wiki","title":"E-Agle TRT Wiki"},{"location":"#e-agle-trt-wiki","text":"","title":"E-Agle TRT Wiki"},{"location":"can-cicd/","text":"Build branch The purpose of this branch is to serve the files generated by github actions from the repo, such as config files or libraries and headers that are generated by this project for various languages. Subprojects' output files project root\\ \u251c id_generator \\ \u251c naked_generator \\ \u251c includes_generator \\ \u251c sheet_generator \\ \u2514 external The external folder is only present in this branch and contains external tools that might be needed for the implementation of the generated files.","title":"Build branch"},{"location":"can-cicd/#build-branch","text":"The purpose of this branch is to serve the files generated by github actions from the repo, such as config files or libraries and headers that are generated by this project for various languages.","title":"Build branch"},{"location":"can-cicd/#subprojects-output-files","text":"project root\\ \u251c id_generator \\ \u251c naked_generator \\ \u251c includes_generator \\ \u251c sheet_generator \\ \u2514 external The external folder is only present in this branch and contains external tools that might be needed for the implementation of the generated files.","title":"Subprojects' output files"},{"location":"common/openocd-errors/","text":"OpenOCD errors Error connecting DP: cannot read IDR CONDITIONS The following conditions can be observed by using a DAPlink programmer. Enable debug mode level >0 for openOCD, this can be done either via: openocd -d3 ...other_parameters... If using the extension cortex-debug in VSCode, by adding: in file openocd.cfg ------- debug_level 3 If the output of openocd contains: Debug: 229 931 cmsis_dap.c:646 cmsis_dap_swd_read_process(): SWD ack not OK @ 0 JUNK Error: 230 932 adi_v5_swd.c:144 swd_connect(): Error connecting DP: cannot read IDR Debug: 231 932 command.c:628 run_command(): Command 'dap init' failed with error code -4 User : 232 932 command.c:694 command_run_line(): Then the problem is likely to be hardware, i.e. the programmer (DAPlink) is unable to connect/talk to the target via SWD. See this mailling list thread. SOLUTION Check VDD voltages: Do they reach the micro? Are they the correct value? Are there short-circuits to GND ? Check continuity on SWDIO and SWCLK lines Are the mircos' pins soldered to the board? Is the micro correctly oriented on the pcb? Check the DAP connection Do the jumper-wires work?","title":"OpenOCD errors"},{"location":"common/openocd-errors/#openocd-errors","text":"","title":"OpenOCD errors"},{"location":"common/openocd-errors/#error-connecting-dp-cannot-read-idr","text":"","title":"Error connecting DP: cannot read IDR"},{"location":"common/openocd-errors/#conditions","text":"The following conditions can be observed by using a DAPlink programmer. Enable debug mode level >0 for openOCD, this can be done either via: openocd -d3 ...other_parameters... If using the extension cortex-debug in VSCode, by adding: in file openocd.cfg ------- debug_level 3 If the output of openocd contains: Debug: 229 931 cmsis_dap.c:646 cmsis_dap_swd_read_process(): SWD ack not OK @ 0 JUNK Error: 230 932 adi_v5_swd.c:144 swd_connect(): Error connecting DP: cannot read IDR Debug: 231 932 command.c:628 run_command(): Command 'dap init' failed with error code -4 User : 232 932 command.c:694 command_run_line(): Then the problem is likely to be hardware, i.e. the programmer (DAPlink) is unable to connect/talk to the target via SWD. See this mailling list thread.","title":"CONDITIONS"},{"location":"common/openocd-errors/#solution","text":"Check VDD voltages: Do they reach the micro? Are they the correct value? Are there short-circuits to GND ? Check continuity on SWDIO and SWCLK lines Are the mircos' pins soldered to the board? Is the micro correctly oriented on the pcb? Check the DAP connection Do the jumper-wires work?","title":"SOLUTION"},{"location":"common/about/introduction/","text":"Introduction","title":"Introduction"},{"location":"common/about/introduction/#introduction","text":"","title":"Introduction"},{"location":"common/about/writing-docs/","text":"Writing Documentation Testing the documentation locally You can test locally the exported documentation using the custom docker image generated by the wiki project. Open a terminal in the root folder of your project Make sure the docs/ folder is present Run this command: docker run --rm \\ -p 8000 :8000 \\ -v $( pwd ) /docs:/wiki/docs/<project-name>:z \\ eagletrt/wiki Tip Live reloading works when testing with docker. Notes and warnings !!! note This this a note. Note This this a note. !!! warning This this a warning. Warning This this a warning. Supported types are: note abstract , summary , tldr info , todo tip , hint , important success , check , done question , help , faq warning , caution , attention faliure , fail , missing danger , error bug example quote , cite Mathematical expressions $x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$ \\(x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.\\) Embedding PDFs < object data = \"../sample.pdf\" type = \"application/pdf\" style = \"width: 100%; height: 600px\" > < embed src = \"../sample.pdf\" type = \"application/pdf\" /> </ object >","title":"Writing Documentation"},{"location":"common/about/writing-docs/#writing-documentation","text":"","title":"Writing Documentation"},{"location":"common/about/writing-docs/#testing-the-documentation-locally","text":"You can test locally the exported documentation using the custom docker image generated by the wiki project. Open a terminal in the root folder of your project Make sure the docs/ folder is present Run this command: docker run --rm \\ -p 8000 :8000 \\ -v $( pwd ) /docs:/wiki/docs/<project-name>:z \\ eagletrt/wiki Tip Live reloading works when testing with docker.","title":"Testing the documentation locally"},{"location":"common/about/writing-docs/#notes-and-warnings","text":"!!! note This this a note. Note This this a note. !!! warning This this a warning. Warning This this a warning. Supported types are: note abstract , summary , tldr info , todo tip , hint , important success , check , done question , help , faq warning , caution , attention faliure , fail , missing danger , error bug example quote , cite","title":"Notes and warnings"},{"location":"common/about/writing-docs/#mathematical-expressions","text":"$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$ \\(x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.\\)","title":"Mathematical expressions"},{"location":"common/about/writing-docs/#embedding-pdfs","text":"< object data = \"../sample.pdf\" type = \"application/pdf\" style = \"width: 100%; height: 600px\" > < embed src = \"../sample.pdf\" type = \"application/pdf\" /> </ object >","title":"Embedding PDFs"},{"location":"fenice-bms-hv/","text":"High-Voltage Battery Management System Battery management is a collection of operations that ensure the safety and efficiency of the battery pack. A basic battery management system should constantly measure cell temperatures and voltages along with the total pack current output and check that each of those values is within specification. If anomalies are detected, the battery should be disconnected immediately via the AIRs. A good battery management system is also able to keep the battery in good operating conditions, with the goal of maintaining the expected efficiency of the powertrain. The need of collecting a lot of data from all over the pack has dictated a scattered architecture for the BMS, that uses multiple data acquisition boards (cellboards) and a single control board (mainboard). :caption: 'Mainboard:' :maxdepth: 2 mainboard/index","title":"High-Voltage Battery Management System"},{"location":"fenice-bms-hv/#high-voltage-battery-management-system","text":"Battery management is a collection of operations that ensure the safety and efficiency of the battery pack. A basic battery management system should constantly measure cell temperatures and voltages along with the total pack current output and check that each of those values is within specification. If anomalies are detected, the battery should be disconnected immediately via the AIRs. A good battery management system is also able to keep the battery in good operating conditions, with the goal of maintaining the expected efficiency of the powertrain. The need of collecting a lot of data from all over the pack has dictated a scattered architecture for the BMS, that uses multiple data acquisition boards (cellboards) and a single control board (mainboard). :caption: 'Mainboard:' :maxdepth: 2 mainboard/index","title":"High-Voltage Battery Management System"},{"location":"fenice-bms-hv/mainboard/","text":"Mainboard The Mainboard is the central control unit of the BMS. It contains a microcontroller that handles two CAN-bus lines for internal and external communications, peripherals such as insulated ADCs, EEPROMs, serial ports, an SD-card and more. The mainboard is responsible for the actuation of the AIRs and contains the shutdown and pre-charge circuits. It also communicates voltages, temperatures, currents, battery status, warnings and errors to the rest of the car via CAN-bus. An integrated serial command-line interface and internal logging are included to help with troubleshooting. The logic of the mainboard is handled by a couple of finite state machines (FSM). The fsm library is used to manage every state machine of the BMS. :caption: 'I/O:' :maxdepth: 2 io :caption: 'BMS Finite State Machine:' :maxdepth: 2 bms_fsm","title":"Mainboard"},{"location":"fenice-bms-hv/mainboard/#mainboard","text":"The Mainboard is the central control unit of the BMS. It contains a microcontroller that handles two CAN-bus lines for internal and external communications, peripherals such as insulated ADCs, EEPROMs, serial ports, an SD-card and more. The mainboard is responsible for the actuation of the AIRs and contains the shutdown and pre-charge circuits. It also communicates voltages, temperatures, currents, battery status, warnings and errors to the rest of the car via CAN-bus. An integrated serial command-line interface and internal logging are included to help with troubleshooting. The logic of the mainboard is handled by a couple of finite state machines (FSM). The fsm library is used to manage every state machine of the BMS. :caption: 'I/O:' :maxdepth: 2 io :caption: 'BMS Finite State Machine:' :maxdepth: 2 bms_fsm","title":"Mainboard"},{"location":"fenice-bms-hv/mainboard/bms_fsm/","text":"BMS FSM The BMS FSM handles the main logic of the battery management. \\begin{tikzpicture}[->, >=stealth', shorten >= 5pt, node distance = 2.5cm, semithick] \\node[state, initial] (idle) {$Idle$}; \\node[state] (pc) [right=of idle] {$PC$}; \\node[state] (ts_on) [right=of pc] {$TS_{on}$}; \\node[state] (error) [above=of pc] {$Error$}; \\path (idle) edge[loop below] (idle) edge (pc) edge[bend left] (error); \\path (pc) edge (ts_on) edge (error) edge[loop below] (pc); \\path (ts_on) edge[loop below] (ts_on) edge (error) edge[bend left=40] (idle); \\path (error) edge[loop right] (error) edge (idle); \\end{tikzpicture} - Idle When the TS is off and no fatal errors are present, the BMS is in the Idle state. - Pre-Charge The Pre-Charge procedure is done to turn on the Tractive System. It involves the actuation of the AIRs and the monitoring of the bus voltage. In the entry phase of the pre-charge state, the negative AIR is closed. This initiates the pre-charge procedure. The bus voltage is periodically confronted with the internal voltage and when they are within 10% of each other the positive AIR is closed, ending the pre-charge procedure. The FSM then transitions to the TS_On state. If the bus voltage doesn't rise fast enough, the pre-charge fails and the FSM goes back to Idle. - TS_On In this state the high-voltage bus external to the battery is powered. This is the state in which the car can run, or the battery can be charged. When the TS_OFF event occurs, the FSM transitions back to Idle, opening both AIRs at the same time. - Error If a fatal error is active the BMS is in this state. If every fatal error expires, then the BMS returns to Idle and can be turned on again.","title":"Bms fsm"},{"location":"fenice-bms-hv/mainboard/bms_fsm/#bms-fsm","text":"The BMS FSM handles the main logic of the battery management. \\begin{tikzpicture}[->, >=stealth', shorten >= 5pt, node distance = 2.5cm, semithick] \\node[state, initial] (idle) {$Idle$}; \\node[state] (pc) [right=of idle] {$PC$}; \\node[state] (ts_on) [right=of pc] {$TS_{on}$}; \\node[state] (error) [above=of pc] {$Error$}; \\path (idle) edge[loop below] (idle) edge (pc) edge[bend left] (error); \\path (pc) edge (ts_on) edge (error) edge[loop below] (pc); \\path (ts_on) edge[loop below] (ts_on) edge (error) edge[bend left=40] (idle); \\path (error) edge[loop right] (error) edge (idle); \\end{tikzpicture}","title":"BMS FSM"},{"location":"fenice-bms-hv/mainboard/bms_fsm/#-idle","text":"When the TS is off and no fatal errors are present, the BMS is in the Idle state.","title":"- Idle"},{"location":"fenice-bms-hv/mainboard/bms_fsm/#-pre-charge","text":"The Pre-Charge procedure is done to turn on the Tractive System. It involves the actuation of the AIRs and the monitoring of the bus voltage. In the entry phase of the pre-charge state, the negative AIR is closed. This initiates the pre-charge procedure. The bus voltage is periodically confronted with the internal voltage and when they are within 10% of each other the positive AIR is closed, ending the pre-charge procedure. The FSM then transitions to the TS_On state. If the bus voltage doesn't rise fast enough, the pre-charge fails and the FSM goes back to Idle.","title":"- Pre-Charge"},{"location":"fenice-bms-hv/mainboard/bms_fsm/#-ts_on","text":"In this state the high-voltage bus external to the battery is powered. This is the state in which the car can run, or the battery can be charged. When the TS_OFF event occurs, the FSM transitions back to Idle, opening both AIRs at the same time.","title":"- TS_On"},{"location":"fenice-bms-hv/mainboard/bms_fsm/#-error","text":"If a fatal error is active the BMS is in this state. If every fatal error expires, then the BMS returns to Idle and can be turned on again.","title":"- Error"},{"location":"fenice-bms-hv/mainboard/io/","text":"I/O Overview There are many peripherals and devices connected to the mainboard. Every component that interfaces with the mainboard's microcontroller is listed here: - CAN-buses (CAN): A CAN-bus to communicate with the car and an internal isolated bus for handling the cellboards. - Si8900 isolated ADC (UART): Used to measure pack and bus voltages, and is also used to measure the pack current using a shunt resistor. - DAHB S/160 Hall-effect sensor (ADC): Used to measure pack current. Less precise than the shunt, included for historic reasons. The unit contains two sensors with different gains to have a broader current range. - AIR and pre-charge controls : Three output pins control the actuation of the AIRs (if the shutdown circuit is not latched in the off state) and the pre-charge circuit. - Circuit feedbacks (MUX/ADC): 16 multiplexed analog signals coming from the mainboard's circuit. Used to diagnose the circuit and to verify its correct state compared to the BMS state. Some of those feedbacks are not multiplexed to permit the generation of interrupts from them. - IMD Status (PWM): The IMD has an output PWM signal that reports its internal state. - M95256 EEPROM (SPI): Used to store runtime variables and data, such as state of charge information, balancing threshold and more. - SD-card (SPI): An SD-card is included on the mainboard to be used as storage for extended logs. - User console (UART): A serial interface is reserved as an user interface to read/write data and execute commands. The cli library is used as an interface. - GPIOs : 9 GPIO pins for external stuff.","title":"Io"},{"location":"fenice-bms-hv/mainboard/io/#io-overview","text":"There are many peripherals and devices connected to the mainboard. Every component that interfaces with the mainboard's microcontroller is listed here: - CAN-buses (CAN): A CAN-bus to communicate with the car and an internal isolated bus for handling the cellboards. - Si8900 isolated ADC (UART): Used to measure pack and bus voltages, and is also used to measure the pack current using a shunt resistor. - DAHB S/160 Hall-effect sensor (ADC): Used to measure pack current. Less precise than the shunt, included for historic reasons. The unit contains two sensors with different gains to have a broader current range. - AIR and pre-charge controls : Three output pins control the actuation of the AIRs (if the shutdown circuit is not latched in the off state) and the pre-charge circuit. - Circuit feedbacks (MUX/ADC): 16 multiplexed analog signals coming from the mainboard's circuit. Used to diagnose the circuit and to verify its correct state compared to the BMS state. Some of those feedbacks are not multiplexed to permit the generation of interrupts from them. - IMD Status (PWM): The IMD has an output PWM signal that reports its internal state. - M95256 EEPROM (SPI): Used to store runtime variables and data, such as state of charge information, balancing threshold and more. - SD-card (SPI): An SD-card is included on the mainboard to be used as storage for extended logs. - User console (UART): A serial interface is reserved as an user interface to read/write data and execute commands. The cli library is used as an interface. - GPIOs : 9 GPIO pins for external stuff.","title":"I/O Overview"},{"location":"fenice-ecu/","text":"Electronic Control Unit Fenice's ECU controls the global state of the vehicle and manages its transitions between states. For example, when the driver requests the car to enter the RUN state, the ECU will execute all needed operations and will prepare the vehicle to meet all needed constraints in order to safely move. Although its main task is rather simple, this component is actually composed of many modules. The first reason is that this apparently small state machine conceals quite a lot of abstraction, therefore needing a certain quantity of code in order to reach down to the low level of a micro-controller interface. The second reason follows from the first, meaning that all this code, in order to remain maintainable and reliable in time, needs a proper level of modularization and separation. :caption: 'Vehicle State Machine:' :maxdepth: 2 fsm/fsm.md :caption: 'ECU Modules:' :maxdepth: 2 modules/modules.md","title":"Electronic Control Unit"},{"location":"fenice-ecu/#electronic-control-unit","text":"Fenice's ECU controls the global state of the vehicle and manages its transitions between states. For example, when the driver requests the car to enter the RUN state, the ECU will execute all needed operations and will prepare the vehicle to meet all needed constraints in order to safely move. Although its main task is rather simple, this component is actually composed of many modules. The first reason is that this apparently small state machine conceals quite a lot of abstraction, therefore needing a certain quantity of code in order to reach down to the low level of a micro-controller interface. The second reason follows from the first, meaning that all this code, in order to remain maintainable and reliable in time, needs a proper level of modularization and separation. :caption: 'Vehicle State Machine:' :maxdepth: 2 fsm/fsm.md :caption: 'ECU Modules:' :maxdepth: 2 modules/modules.md","title":"Electronic Control Unit"},{"location":"fenice-ecu/fsm/fsm/","text":"Finite State Machine","title":"Finite State Machine"},{"location":"fenice-ecu/fsm/fsm/#finite-state-machine","text":"","title":"Finite State Machine"},{"location":"fenice-ecu/modules/modules/","text":"Modules UART Several serial communication interfaces are used: Interface TX Pin RX Pin Baud Rate Description UART4 PA12 PA13 115200 Debugging messages ... Front Right Encoder ... Front Left Encoder ... Steering Encoder For more details on the encoders, see the dedicated section below . Timers List of STM timers employed: Timer Pin Description TIM10 PB8 Buzzer PWM output Buzzer As required by the rulebook, the ECU must beep a buzzer for at least (?) ... The buzzer is driven by a MOSFET operated via the PWM output generated by the TIM10 timer on pin PB8, and powered by the 12V line. CAN Fenice's internal networks operate on two CAN buses. Networks Network Interface CAN_TX Pin CAN_RX Pin Primary CAN1 PD1 PD0 Secondary CAN3 PB4 PA8 Bit Timing Parameters APB1 Peripheral Clock (PCLK1): 54 MHz Prescaler: 3 Time Quantum is therefore 55.555 ns Time Quanta in Bit Segment 1: 12 Time Quanta in Bit Segment 2: 5 Time for one bit is therefore 999.99 ns Baud rate is therefore 1000000 bps ( 1 Mbit/s ) ReSynchronization Jump Width: 1 Messages For the list and definition of all CAN messages please refer to the can-cicd documentation . SPI The SPI interface is used to communicate with the Traction Control Unit and exchange information on vehicle state and motor torque. Since the TCU runs on a Raspberry Pi which is, by design, only capable of operating as a Master node, the ECU acts as the Slave node. Interface CLK Pin ... ... For more information on how and what information is exchanged, please refer to the Traction Control section below. IMU This module records the acceleration data coming from the Inertial Measurement Unit (IMU) sensor over the CAN network. Namely, it receives: - Linear acceleration on the three directions - Gyroscopic acceleration on the three axes Sensor Configuration In order to work properly, the sensor needs to be configured with the following parameters: - Sampling frequency: ? - ... IRTS Four Infra-Red Temperature Sensors (IRTSs) are pointed toward the tires and measure their temperature gradient using 8 (?) channels each (...) Inverters The Inverters and the ECU communicate over the CAN network and exchange the following information: - The ECU periodically (at which freq. ?) sends two torque values to be applied to the motors, one for the left side and one for the right side - The inverters periodically (every 100ms) report the contents of their status register (more details below) - The inverters periodically (every 100ms) report the output voltage at which they are driving the motors Status Register Contents Bit Symbol Description 0 Ena Drive Enable 1 RcR0 Speed limit to zero 2 Lim+ Limited switch + tripped 3 Lim- Limited switch - tripped 4 OK Drive okay 5 Icns Current is limited to the continuous current level 6 T-Nlim Speed limit torque mode active 7 P-N Position control active 8 N-I Speed control active 9 <N0 Actual speed is less than 0.1% 10 Rsw Reference switch tripped 11 Cal0 Calibration move active 12 Cal Calibration move completed 13 Tol Position within tolerance window 14 Rdy Drive ready (BTB/RDY contact closed) 15 Brk0 Unexcited brake with motor active 16 SignMag Speed internally inverted 17 Nclip Speed limiting enabled (N-Lim < 90%) 18 Nclip+ Speed limiting (+) via input switch enabled 19 Ncip- Speed limiting (-) via input switch enabled 20 Ird-Dig Current limiting via input switch enabled 21 Iuse-rchd Actual current limit reached 22 Ird-N Current derating to cont. current via speed limit enabled 23 Ird-TI Current derating to cont. current due to igbt temp. enabled 24 Ird-TIR Current derating to cont. current due to igbt temp. active 25 >10Hz Current derating to cont. current at rotation freq. < 10 Hz active 26 Ird-TM Current derating to cont. current due to motor temp. active 27 Ird-Ana Current derating due to analog input (if <= 90%) possible 28 Iwcns Current peak value warning 29 RFEpulse Pulsed RFE - input monitoring active 30 M+d vacant 31 HndWhl Hand-wheel function selected Current-Torque Curve and Power Limiting Since, for a given current, power absorption of the motors is proportional to their rotational speed, and given that inverters are controlled in torque/current mode, care must be taken not to request more than the allowed limit of 80 KWh. More details on the matter are available in this report: {pdfembed} src:./Powertrain_Transmission_Optimal_Parameters.pdf, height:400, width:100%, align:middle Essentially, requesting the maximum available current of 200A when the angular velocity is above 4000 RPM causes the power to exceed the allowed limit. To overcome this issue, the following equation must then be followed to obtain the correct torque limit at each rotational speed: \\(C_{mot\\_max} = \\begin{cases} C_{max} & \\text{if \\(\\omega_{mot} < \\omega_{limit}\\) } \\ \\frac{358098.6}{\\omega_{mot}} & \\text{if \\(\\omega_{mot} \\geq \\omega_{limit}\\) }\\) PCU This module controls all communication (via CAN-Bus) between the ECU and the Pedal Control Unit (PCU). More specifically: - ADC brake and accelerator values are read and scaled from 0 to 100 - Errors and Warnings are checked (e.g. implausibility) - Calibration values are read/written from/to the EEPROM and sent/received Tractive System The TC code handles the generation and delivery of messages concerning the status of the BMS-HV (PRECHARGE, TS-ON, TS-OFF, ...). Traction Control Since the actual software for controlling the traction of the vehicle runs on a separate device (for reliability purposes), the ECU and the Traction Control Unit (TCU) need to constantly exchange a number of values. Parameter Name Direction Description Brake ECU -> TCU How much the brake pedal is pressed ... Further technical details on how this data is exchanged over SPI can be found at the TCU Protocol page. Encoders ...","title":"Modules"},{"location":"fenice-ecu/modules/modules/#modules","text":"","title":"Modules"},{"location":"fenice-ecu/modules/modules/#uart","text":"Several serial communication interfaces are used: Interface TX Pin RX Pin Baud Rate Description UART4 PA12 PA13 115200 Debugging messages ... Front Right Encoder ... Front Left Encoder ... Steering Encoder For more details on the encoders, see the dedicated section below .","title":"UART"},{"location":"fenice-ecu/modules/modules/#timers","text":"List of STM timers employed: Timer Pin Description TIM10 PB8 Buzzer PWM output","title":"Timers"},{"location":"fenice-ecu/modules/modules/#buzzer","text":"As required by the rulebook, the ECU must beep a buzzer for at least (?) ... The buzzer is driven by a MOSFET operated via the PWM output generated by the TIM10 timer on pin PB8, and powered by the 12V line.","title":"Buzzer"},{"location":"fenice-ecu/modules/modules/#can","text":"Fenice's internal networks operate on two CAN buses.","title":"CAN"},{"location":"fenice-ecu/modules/modules/#networks","text":"Network Interface CAN_TX Pin CAN_RX Pin Primary CAN1 PD1 PD0 Secondary CAN3 PB4 PA8","title":"Networks"},{"location":"fenice-ecu/modules/modules/#bit-timing-parameters","text":"APB1 Peripheral Clock (PCLK1): 54 MHz Prescaler: 3 Time Quantum is therefore 55.555 ns Time Quanta in Bit Segment 1: 12 Time Quanta in Bit Segment 2: 5 Time for one bit is therefore 999.99 ns Baud rate is therefore 1000000 bps ( 1 Mbit/s ) ReSynchronization Jump Width: 1","title":"Bit Timing Parameters"},{"location":"fenice-ecu/modules/modules/#messages","text":"For the list and definition of all CAN messages please refer to the can-cicd documentation .","title":"Messages"},{"location":"fenice-ecu/modules/modules/#spi","text":"The SPI interface is used to communicate with the Traction Control Unit and exchange information on vehicle state and motor torque. Since the TCU runs on a Raspberry Pi which is, by design, only capable of operating as a Master node, the ECU acts as the Slave node. Interface CLK Pin ... ... For more information on how and what information is exchanged, please refer to the Traction Control section below.","title":"SPI"},{"location":"fenice-ecu/modules/modules/#imu","text":"This module records the acceleration data coming from the Inertial Measurement Unit (IMU) sensor over the CAN network. Namely, it receives: - Linear acceleration on the three directions - Gyroscopic acceleration on the three axes","title":"IMU"},{"location":"fenice-ecu/modules/modules/#sensor-configuration","text":"In order to work properly, the sensor needs to be configured with the following parameters: - Sampling frequency: ? - ...","title":"Sensor Configuration"},{"location":"fenice-ecu/modules/modules/#irts","text":"Four Infra-Red Temperature Sensors (IRTSs) are pointed toward the tires and measure their temperature gradient using 8 (?) channels each (...)","title":"IRTS"},{"location":"fenice-ecu/modules/modules/#inverters","text":"The Inverters and the ECU communicate over the CAN network and exchange the following information: - The ECU periodically (at which freq. ?) sends two torque values to be applied to the motors, one for the left side and one for the right side - The inverters periodically (every 100ms) report the contents of their status register (more details below) - The inverters periodically (every 100ms) report the output voltage at which they are driving the motors","title":"Inverters"},{"location":"fenice-ecu/modules/modules/#status-register-contents","text":"Bit Symbol Description 0 Ena Drive Enable 1 RcR0 Speed limit to zero 2 Lim+ Limited switch + tripped 3 Lim- Limited switch - tripped 4 OK Drive okay 5 Icns Current is limited to the continuous current level 6 T-Nlim Speed limit torque mode active 7 P-N Position control active 8 N-I Speed control active 9 <N0 Actual speed is less than 0.1% 10 Rsw Reference switch tripped 11 Cal0 Calibration move active 12 Cal Calibration move completed 13 Tol Position within tolerance window 14 Rdy Drive ready (BTB/RDY contact closed) 15 Brk0 Unexcited brake with motor active 16 SignMag Speed internally inverted 17 Nclip Speed limiting enabled (N-Lim < 90%) 18 Nclip+ Speed limiting (+) via input switch enabled 19 Ncip- Speed limiting (-) via input switch enabled 20 Ird-Dig Current limiting via input switch enabled 21 Iuse-rchd Actual current limit reached 22 Ird-N Current derating to cont. current via speed limit enabled 23 Ird-TI Current derating to cont. current due to igbt temp. enabled 24 Ird-TIR Current derating to cont. current due to igbt temp. active 25 >10Hz Current derating to cont. current at rotation freq. < 10 Hz active 26 Ird-TM Current derating to cont. current due to motor temp. active 27 Ird-Ana Current derating due to analog input (if <= 90%) possible 28 Iwcns Current peak value warning 29 RFEpulse Pulsed RFE - input monitoring active 30 M+d vacant 31 HndWhl Hand-wheel function selected","title":"Status Register Contents"},{"location":"fenice-ecu/modules/modules/#current-torque-curve-and-power-limiting","text":"Since, for a given current, power absorption of the motors is proportional to their rotational speed, and given that inverters are controlled in torque/current mode, care must be taken not to request more than the allowed limit of 80 KWh. More details on the matter are available in this report: {pdfembed} src:./Powertrain_Transmission_Optimal_Parameters.pdf, height:400, width:100%, align:middle Essentially, requesting the maximum available current of 200A when the angular velocity is above 4000 RPM causes the power to exceed the allowed limit. To overcome this issue, the following equation must then be followed to obtain the correct torque limit at each rotational speed: \\(C_{mot\\_max} = \\begin{cases} C_{max} & \\text{if \\(\\omega_{mot} < \\omega_{limit}\\) } \\ \\frac{358098.6}{\\omega_{mot}} & \\text{if \\(\\omega_{mot} \\geq \\omega_{limit}\\) }\\)","title":"Current-Torque Curve and Power Limiting"},{"location":"fenice-ecu/modules/modules/#pcu","text":"This module controls all communication (via CAN-Bus) between the ECU and the Pedal Control Unit (PCU). More specifically: - ADC brake and accelerator values are read and scaled from 0 to 100 - Errors and Warnings are checked (e.g. implausibility) - Calibration values are read/written from/to the EEPROM and sent/received","title":"PCU"},{"location":"fenice-ecu/modules/modules/#tractive-system","text":"The TC code handles the generation and delivery of messages concerning the status of the BMS-HV (PRECHARGE, TS-ON, TS-OFF, ...).","title":"Tractive System"},{"location":"fenice-ecu/modules/modules/#traction-control","text":"Since the actual software for controlling the traction of the vehicle runs on a separate device (for reliability purposes), the ECU and the Traction Control Unit (TCU) need to constantly exchange a number of values. Parameter Name Direction Description Brake ECU -> TCU How much the brake pedal is pressed ... Further technical details on how this data is exchanged over SPI can be found at the TCU Protocol page.","title":"Traction Control"},{"location":"fenice-ecu/modules/modules/#encoders","text":"...","title":"Encoders"},{"location":"fenice-steeringwheel/","text":"Steering Wheel Welcome to the Fenice Steering Wheel documentation. Fenice Steering Wheel is a modular Qt application that interacts with the rest of the vehicle and displays useful information to the team and the pilot during preparation or race. In production the software is deployed to a Raspberry Pi 3b+ into a custom PCB that allows simple communications with all the I/O of the device. During development the software can be tested on any x86 machine that supports Qt natively. Most of the custom I/O is abstracted so complex interaction can still be tested.","title":"Steering Wheel"},{"location":"fenice-steeringwheel/#steering-wheel","text":"Welcome to the Fenice Steering Wheel documentation. Fenice Steering Wheel is a modular Qt application that interacts with the rest of the vehicle and displays useful information to the team and the pilot during preparation or race. In production the software is deployed to a Raspberry Pi 3b+ into a custom PCB that allows simple communications with all the I/O of the device. During development the software can be tested on any x86 machine that supports Qt natively. Most of the custom I/O is abstracted so complex interaction can still be tested.","title":"Steering Wheel"},{"location":"fenice-steeringwheel/development/qt/","text":"Building Qt for the Raspberry Pi This guide is an edited version of the original by abhiTronix . Prerequites A. Hardware Host: Any x86 / x86_64 AMD / Intel machine Target: Raspberry Pi any variant / module B. Software Host: Any Linux machine (Ubuntu 20.04 Tested) Target: Any Raspberry Pi Linux 32-bit OS (Raspbian Buster Tested) C. Others Storage and Time Requirements: The build directory takes around \\~10GB space and about 2-5 hours to complete (based on dependencies & Host Machine Specifications) . Networking: Your Target Machine (Raspberry Pi) and Host Machine (where you cross-compiling) both must have internet access, and must be on same network to follow these instructions. Setup the Target Machine 1. Start from Scratch (Optional) Important: If you just brought a new Raspberry Pi or wanted to start from scratch just follow along. Otherwise, if you already has your Raspberry Pi setup, running, and Network Ready, then just skip to step 2 . Note: This section assume you have atleast 10GB SDcard for installing Raspbian Buster OS and a Laptop/PC for uploading it. 1.1. Download Softwares & Prepare the SD card Download the latest version of Raspbian (Buster) from here on your laptop/pc. You will be needing an image writer to write the downloaded OS into the SD card (micro SD card in our case) . So download the open-source \u201cwin32 disk imager\u201d from here , OR you can also use Balena Etcher instead. Insert the SD card into the laptop/pc and run the image writer. Once open, browse and select the downloaded Raspbian image file. Select the correct device, that is the drive representing the SD card. Note: If the drive (or device) selected is different from the SD card then the other selected drive will become corrupted. SO BE CAREFUL! Once the write is complete, eject the SD card and insert it into the Raspberry Pi and turn it on. It should start booting up. Please remember that after booting the Pi, there might be situations when the user credentials like the \u201cusername\u201d and password will be asked. Raspberry Pi comes with a default username pi and password raspberry and so use it whenever it is being asked. 1.2 Set up Network Now the you have your Raspberry Pi up and Running, its time to connect it your network with one of following ways: If you have Monitor . If you don\u2019t have Monitor Any other way 2. Set up SSH If you have Monitor: On the Raspberry Pi terminal, type: sudo raspi-config and menu should pop up on your terminal. To enable SSH, go to: Interfacing Options -> SSH -> Yes , and Click OK to enable it. Choose Finish finally and exit. If you don\u2019t have Monitor: After setting up the network, if you don\u2019t have monitor or you operating it remotely. Then, enable SSH by just taking out your SD card, and hook it your computer, and simply create an empty file called ssh in the /boot/parition path inside SD card. Now insert back SD card into the Raspberry Pi. 3. Open Terminal From another Laptop/PC using SSH: To connect to your Pi from a different computer, copy and paste the following command into the terminal window but replace 192.160.1.47 with the IP address of the Raspberry Pi. Use Ctrl + Shift + V to paste in the terminal. ssh pi@192.168.1.47 It will ask for password, and if not changed, it is default ( raspberry ), and so use it whenever it is being asked. Note: It is possible to configure your Raspberry Pi to allow access from another computer without needing to provide a password each time you connect. For more details, see here . On Raspberry Pi directly with a Monitor: Just search \u201cTerminal\u201d and click on it. 4. Enable GL (FAKE KMS) To enable Fake KMS, type sudo raspi-config on your terminal to open a menu, then go to: Advanced Options -> A8 GL Driver -> G2 GL (Fake KMS) That should enable KMS. Choose Finish finally and exit. Note: If you are using a minimal build, you may be prompted to download some updates before this option becomes available. If asked, do so. 5. Enable Development Sources You need to edit your sources list to enable development sources. To do this, enter the following command into pi terminal: sudo nano /etc/apt/sources.list In the nano text editor, uncomment the following line by removing the # character from following line: deb-src http://raspbian.raspberrypi.org/raspbian/ buster main contrib non-free rpi When done, press Ctrl+O and then ENTER to quit. 6. Update the system Run the following commands in terminal to update the system sudo apt update sudo apt dist-upgrade 7. Enable rsync with elevated rights Later in this guide, we will be using the rsync command to sync files between the Host PC/Laptop and the Raspberry Pi. For some of these files, root rights (i.e. sudo) is required internally. You can do this with a single terminal command as follows: echo \" $USER ALL=NOPASSWD: $( which rsync ) \" | sudo tee --append /etc/sudoers That\u2019s it. Now rsync should be setup to run with sudo if needed. 8. Install the important Development Packages Run the following commands in Raspberry Pi terminal to install the required packages: sudo apt install build-essential cmake unzip pkg-config gfortran sudo apt build-dep qt5-qmake libqt5gui5 libqt5webengine-data libqt5webkit5 libudev-dev libinput-dev libts-dev libxcb-xinerama0-dev libxcb-xinerama0 gdbserver sudo apt install libxcb-randr0-dev libxcb-xtest0-dev libxcb-shape0-dev libxcb-xkb-dev 9. Additional packages (Optional) You can install these packages if you want additional multimedia and bluetooth capability with your QT binaries: # additional (multimedia) packages sudo apt install libjpeg-dev libpng-dev libtiff-dev sudo apt install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev sudo apt install libxvidcore-dev libx264-dev # audio packages sudo apt install libopenal-data libsndio7.0 libopenal1 libopenal-dev pulseaudio # bluetooth packages sudo apt install bluez-tools sudo apt install libbluetooth-dev # gstreamer (multimedia) packages sudo apt install libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc gstreamer1.0-tools gstreamer1.0-x gstreamer1.0-alsa gstreamer1.0-gl gstreamer1.0-gtk3 gstreamer1.0-qt5 gstreamer1.0-pulseaudio sudo apt install libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev 10. Create directory for QT Deployment Now we create directories where the built QT Binaries will be deployed to your the Rasberry Pi, with following commands: sudo mkdir /usr/local/qt5.15 sudo chown -R pi:pi /usr/local/qt5.15 Also don\u2019t forget to setup Important Symlinks as follows: (Important) sudo ln -sf -r /usr/include/arm-linux-gnueabihf/asm /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/gnu /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/bits /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/sys /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/openssl /usr/include sudo ln -sf /usr/lib/arm-linux-gnueabihf/crtn.o /usr/lib/crtn.o sudo ln -sf /usr/lib/arm-linux-gnueabihf/crt1.o /usr/lib/crt1.o sudo ln -sf /usr/lib/arm-linux-gnueabihf/crti.o /usr/lib/crti.o That\u2019s it for Raspberry Pi setup. Setup the Host Machine Now Raspberry Pi Side all setup, Let\u2019s focus on commands for our Host Machine, i.e. PC/Laptop, where you going to cross-compile the QT Binaries for your Raspberry Pi. Important: Make sure your Raspberry Pi and this Host machine (where you cross-compiling) MUST be on the SAME Network. 1. Update the Host Machine First of all, Run the following commands to update your system and install important dependancies: sudo apt update sudo apt dist-upgrade sudo apt install build-essential cmake unzip gfortran sudo apt install gcc git bison python gperf pkg-config gdb-multiarch wget sudo apt-get -y install gcc g++ gperf flex texinfo gawk bison openssl pigz libncurses-dev autoconf automake tar figlet 2. Setting up the directory structure You can use these following commands to create \u201crpi-qt\u201d to use as workspace for building QT Binaries: sudo mkdir ~/rpi-qt sudo mkdir ~/rpi-qt/build sudo mkdir ~/rpi-qt/tools sudo mkdir ~/rpi-qt/sysroot sudo mkdir ~/rpi-qt/sysroot/usr sudo mkdir ~/rpi-qt/sysroot/opt sudo chown -R 1000 :1000 ~/rpi-qt cd ~/rpi-qt Note: Ensure the last command should have changed your current directory to ~/rpi-qt . If not, run the last line again to make sure you are inside it, as the next steps assume you\u2019re running your commands from this directory. 3. Download & Extract QT Source A. Download Binary Now, we can download the Latest source files for QT LTS (i.e. v5.15.2 ) by running following Terminal command to download the source files: sudo wget http://download.qt.io/archive/qt/5.15/5.15.2/single/qt-everywhere-src-5.15.2.tar.xz Note: You can also manually download file through browser, and place it in the ~/rpi-qt directory. B. Extract Binary Extract the downloaded tar file with the following command: sudo tar xfv qt-everywhere-src-5.15.2.tar.xz 4. Patching QT Source We need to slightly modify the a mkspec file within the source files to allow us to use our cross compiler. We will copy an existing directory within the source files, and modify the name of the directory and the contents of the qmake.conf file within that directory to follow the name of our compiler. To do this, run the following two command: cp -R qt-everywhere-src-5.15.2/qtbase/mkspecs/linux-arm-gnueabi-g++ qt-everywhere-src-5.15.2/qtbase/mkspecs/linux-arm-gnueabihf-g++ sed -i -e 's/arm-linux-gnueabi-/arm-linux-gnueabihf-/g' qt-everywhere-src-5.15.2/qtbase/mkspecs/linux-arm-gnueabihf-g++/qmake.conf 5. Download & Extract the Precompiled Cross-Compiler Let\u2019s first change into tools directory for downloading our Precompiled Cross-compiler with the following command: cd ~/rpi-qt/tools Note: Ensure the last command should have changed your current directory to ~/rpi-qt/tools now. If not, run it again. A. Copy Binary URL Copy URL from one of following Precompiled Compressed Base-Toolchain (for maximum compatability) based on your Raspberry Pi Variant and OS you installed on it, from below: .. list-table:: :widths: 25 25 50 :header-rows: 1 * - Raspberry Pi Board - Stretch(32-bit) OS - Buster(32-bit) OS * - Raspberry Pi - *Zero/W/WH & 1 Model A/B/A+/B+* - https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Stretch/GCC%206.3.0/Raspberry%20Pi%201%2C%20Zero/cross-gcc-6.3.0-pi_0-1.tar.gz - https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%201%2C%20Zero/cross-gcc-8.3.0-pi_0-1.tar.gz * - Raspberry Pi - *2 & 3 Model A/B* - https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Stretch/GCC%206.3.0/Raspberry%20Pi%202%2C%203/cross-gcc-6.3.0-pi_2-3.tar.gz - https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%202%2C%203/cross-gcc-8.3.0-pi_2-3.tar.gz * - Raspberry Pi - *3 & 4 Model A+/B+ & Compute 3/3-lite/3+* - https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Stretch/GCC%206.3.0/Raspberry%20Pi%203A%2B%2C%203B%2B%2C%204/cross-gcc-6.3.0-pi_3%2B.tar.gz - https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%203A%2B%2C%203B%2B%2C%204/cross-gcc-8.3.0-pi_3%2B.tar.gz Note: You can also use the latest cross-compiler binaries instead. But they are not tested. B. Download Binary After that, paste your copied URL and run the following command to download the Cross-compiler: wget <Copied Binary URL goes here> #for e.g. => wget https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%202%2C%203/cross-gcc-8.3.0-pi_2-3.tar.gz C. Extract Binary Once it is downloaded, we can extract it using the following command: tar xf cross-gcc-*.tar.gz 6. Sync Raspberry Pi sysroot (Most Important) First, let\u2019s move back into the rpi folder as needed for the next sections: cd ~/rpi-qt Now, we need to sync up our sysroot folder with the system files from the Raspberry Pi. We will be using rsync that let us sync (i.e. copy) files from the Raspberry Pi with appropriate permission onto your Host Machine, potentially saving you alot of time. To do this, enter the following commands one by one into your terminal (change ``192.168.1.47`` with the IP address of your Raspberry Pi present on the same network) : Command 1: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/lib sysroot Command 2: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/usr/include sysroot/usr Command 3: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/usr/lib sysroot/usr Command 4: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/opt/vc sysroot/opt Note: Double check after each of the above commands that all the files have been copied to ~/rpi-qt/sysroot folder. There will be an information message if there were any issues. 7. Fix symbolic links The files we copied in the previous step still have symbolic links pointing to the file system on the Raspberry Pi. We need to alter this so that they become relative links from the new sysroot directory on the host machine. We can do this with a python script, which we can download as follows: wget https://raw.githubusercontent.com/abhiTronix/rpi_rootfs/master/scripts/sysroot-relativelinks.py Once it is downloaded, you just need to make it executable and run it, using the following commands: sudo chmod +x sysroot-relativelinks.py ./sysroot-relativelinks.py sysroot 8. Configure QT Build Let\u2019s move into the build directory for further steps, as we don\u2019t want to build within that source directory as its crowded, so we will access it from within this this directory: cd ~/rpi-qt/build Finally, Now we can configure our QT build. We need to run the configure script inside QT source to configure our build. Run following command to configure the build, including all the necessary options: CROSS_COMPILER_LOCATION = $HOME /rpi-qt/tools/cross-pi-gcc-* ../qt-everywhere-src-5.15.2/configure -release -opengl es2 -eglfs -device linux-rasp-pi4-v3d-g++ -device-option CROSS_COMPILE = $( echo $CROSS_COMPILER_LOCATION ) /bin/arm-linux-gnueabihf- -sysroot ~/rpi-qt/sysroot/ -prefix /usr/local/qt5.15 -extprefix ~/rpi-qt/qt5.15 -opensource -confirm-license -skip qtscript -skip qtwayland -skip qtwebengine -nomake tests -make libs -pkg-config -no-use-gold-linker -v -recheck -L $HOME /rpi-qt/sysroot/usr/lib/arm-linux-gnueabihf -I $HOME /rpi-qt/sysroot/usr/include/arm-linux-gnueabihf The configure script may take a few minutes to complete. 8.1 Check Configure Output Once it is completed you should get a summary of what has been configured. Make sure the following options appear: Configure summary: Building on: linux-g++ ( x86_64, CPU features: mmx sse sse2 ) Building for : devices/linux-rasp-pi4-v3d-g++ ( arm, CPU features: neon ) Target compiler: gcc 8 .3.0 Configuration: cross_compile compile_examples enable_new_dtags largefile neon precompile_header shared shared rpath release c++11 c++14 c++17 c++1z concurrent dbus reduce_exports stl 8.2 Check if EGLFS enabled QPA backends: EGLFS .................................. yes [ SHOULD BE YES ] EGLFS details: EGLFS OpenWFD ........................ no EGLFS i.Mx6 .......................... no EGLFS i.Mx6 Wayland .................. no EGLFS RCAR ........................... no EGLFS EGLDevice ...................... yes [ SHOULD BE YES ] EGLFS GBM ............................ yes EGLFS VSP2 ........................... no EGLFS Mali ........................... no EGLFS Raspberry Pi ................... no [ SHOULD BE NO ] EGLFS X11 ............................ yes If the your configuration summary doesn\u2019t have the EGLFS features set to what\u2019s shown above, something has probably gone wrong. You can look at the config.log file in the build directory to try and diagnose what the issue might be. If all looks good and all libraries you need have been installed we can continue to the next section 9. Build QT Source Our build has been configured now, and it is time to actually build the source files, and run the following command: Important: Ensure you are still in the ~/rpi-qt/build directory make -j $( nproc ) Note: -j$(nproc) option indicates that the job should be spread into mutliple threads and run in parallel on available cores. \u2615\ufe0f This process will take some time! 10. Install QT Source Once it is completed, we can install the built package using the following command: make install This should install the files in the correct directories 11. Deploy QT to Raspberry Pi First move back into the rpi folder using the following command: cd ~/rpi-qt Now, We can now deploy built QT Binaries (contained in ``qt5.15`` folder in ``~/rpi-qt`` directory) back to our Raspberry Pi, again using rsync command. Just run the following command (change ``192.168.1.47`` with the IP address of your Raspberry Pi present on the same network) : rsync -avz --rsync-path = \"sudo rsync\" qt5.15 pi@192.168.1.47:/usr/local Final Step for Target Machine Update linker on Raspberry Pi Enter the following command to update the device letting the linker to find the new QT binary files: echo /usr/local/qt5.15/lib | sudo tee /etc/ld.so.conf.d/qt5.15.conf sudo ldconfig For Raspberry Pi 2: If you\u2019re facing issues with running the example, try to use 00-qt5pi.conf instead of qt5pi.conf , in the above command. \ud83c\udf7b That should be it! You have now succesfully installed latest QT 5.15.2 on the Raspberry Pi.","title":"Building Qt for the Raspberry Pi"},{"location":"fenice-steeringwheel/development/qt/#building-qt-for-the-raspberry-pi","text":"This guide is an edited version of the original by abhiTronix .","title":"Building Qt for the Raspberry Pi"},{"location":"fenice-steeringwheel/development/qt/#prerequites","text":"","title":"Prerequites"},{"location":"fenice-steeringwheel/development/qt/#a-hardware","text":"Host: Any x86 / x86_64 AMD / Intel machine Target: Raspberry Pi any variant / module","title":"A. Hardware"},{"location":"fenice-steeringwheel/development/qt/#b-software","text":"Host: Any Linux machine (Ubuntu 20.04 Tested) Target: Any Raspberry Pi Linux 32-bit OS (Raspbian Buster Tested)","title":"B. Software"},{"location":"fenice-steeringwheel/development/qt/#c-others","text":"Storage and Time Requirements: The build directory takes around \\~10GB space and about 2-5 hours to complete (based on dependencies & Host Machine Specifications) . Networking: Your Target Machine (Raspberry Pi) and Host Machine (where you cross-compiling) both must have internet access, and must be on same network to follow these instructions.","title":"C. Others"},{"location":"fenice-steeringwheel/development/qt/#setup-the-target-machine","text":"","title":"Setup the Target Machine"},{"location":"fenice-steeringwheel/development/qt/#1-start-from-scratch-optional","text":"Important: If you just brought a new Raspberry Pi or wanted to start from scratch just follow along. Otherwise, if you already has your Raspberry Pi setup, running, and Network Ready, then just skip to step 2 . Note: This section assume you have atleast 10GB SDcard for installing Raspbian Buster OS and a Laptop/PC for uploading it.","title":"1. Start from Scratch (Optional)"},{"location":"fenice-steeringwheel/development/qt/#11-download-softwares-prepare-the-sd-card","text":"Download the latest version of Raspbian (Buster) from here on your laptop/pc. You will be needing an image writer to write the downloaded OS into the SD card (micro SD card in our case) . So download the open-source \u201cwin32 disk imager\u201d from here , OR you can also use Balena Etcher instead. Insert the SD card into the laptop/pc and run the image writer. Once open, browse and select the downloaded Raspbian image file. Select the correct device, that is the drive representing the SD card. Note: If the drive (or device) selected is different from the SD card then the other selected drive will become corrupted. SO BE CAREFUL! Once the write is complete, eject the SD card and insert it into the Raspberry Pi and turn it on. It should start booting up. Please remember that after booting the Pi, there might be situations when the user credentials like the \u201cusername\u201d and password will be asked. Raspberry Pi comes with a default username pi and password raspberry and so use it whenever it is being asked.","title":"1.1. Download Softwares &amp; Prepare the SD card"},{"location":"fenice-steeringwheel/development/qt/#12-set-up-network","text":"Now the you have your Raspberry Pi up and Running, its time to connect it your network with one of following ways: If you have Monitor . If you don\u2019t have Monitor Any other way","title":"1.2 Set up Network"},{"location":"fenice-steeringwheel/development/qt/#2-set-up-ssh","text":"If you have Monitor: On the Raspberry Pi terminal, type: sudo raspi-config and menu should pop up on your terminal. To enable SSH, go to: Interfacing Options -> SSH -> Yes , and Click OK to enable it. Choose Finish finally and exit. If you don\u2019t have Monitor: After setting up the network, if you don\u2019t have monitor or you operating it remotely. Then, enable SSH by just taking out your SD card, and hook it your computer, and simply create an empty file called ssh in the /boot/parition path inside SD card. Now insert back SD card into the Raspberry Pi.","title":"2. Set up SSH"},{"location":"fenice-steeringwheel/development/qt/#3-open-terminal","text":"From another Laptop/PC using SSH: To connect to your Pi from a different computer, copy and paste the following command into the terminal window but replace 192.160.1.47 with the IP address of the Raspberry Pi. Use Ctrl + Shift + V to paste in the terminal. ssh pi@192.168.1.47 It will ask for password, and if not changed, it is default ( raspberry ), and so use it whenever it is being asked. Note: It is possible to configure your Raspberry Pi to allow access from another computer without needing to provide a password each time you connect. For more details, see here . On Raspberry Pi directly with a Monitor: Just search \u201cTerminal\u201d and click on it.","title":"3. Open Terminal"},{"location":"fenice-steeringwheel/development/qt/#4-enable-gl-fake-kms","text":"To enable Fake KMS, type sudo raspi-config on your terminal to open a menu, then go to: Advanced Options -> A8 GL Driver -> G2 GL (Fake KMS) That should enable KMS. Choose Finish finally and exit. Note: If you are using a minimal build, you may be prompted to download some updates before this option becomes available. If asked, do so.","title":"4. Enable GL (FAKE KMS)"},{"location":"fenice-steeringwheel/development/qt/#5-enable-development-sources","text":"You need to edit your sources list to enable development sources. To do this, enter the following command into pi terminal: sudo nano /etc/apt/sources.list In the nano text editor, uncomment the following line by removing the # character from following line: deb-src http://raspbian.raspberrypi.org/raspbian/ buster main contrib non-free rpi When done, press Ctrl+O and then ENTER to quit.","title":"5. Enable Development Sources"},{"location":"fenice-steeringwheel/development/qt/#6-update-the-system","text":"Run the following commands in terminal to update the system sudo apt update sudo apt dist-upgrade","title":"6. Update the system"},{"location":"fenice-steeringwheel/development/qt/#7-enable-rsync-with-elevated-rights","text":"Later in this guide, we will be using the rsync command to sync files between the Host PC/Laptop and the Raspberry Pi. For some of these files, root rights (i.e. sudo) is required internally. You can do this with a single terminal command as follows: echo \" $USER ALL=NOPASSWD: $( which rsync ) \" | sudo tee --append /etc/sudoers That\u2019s it. Now rsync should be setup to run with sudo if needed.","title":"7. Enable rsync with elevated rights"},{"location":"fenice-steeringwheel/development/qt/#8-install-the-important-development-packages","text":"Run the following commands in Raspberry Pi terminal to install the required packages: sudo apt install build-essential cmake unzip pkg-config gfortran sudo apt build-dep qt5-qmake libqt5gui5 libqt5webengine-data libqt5webkit5 libudev-dev libinput-dev libts-dev libxcb-xinerama0-dev libxcb-xinerama0 gdbserver sudo apt install libxcb-randr0-dev libxcb-xtest0-dev libxcb-shape0-dev libxcb-xkb-dev","title":"8. Install the important Development Packages"},{"location":"fenice-steeringwheel/development/qt/#9-additional-packages-optional","text":"You can install these packages if you want additional multimedia and bluetooth capability with your QT binaries: # additional (multimedia) packages sudo apt install libjpeg-dev libpng-dev libtiff-dev sudo apt install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev sudo apt install libxvidcore-dev libx264-dev # audio packages sudo apt install libopenal-data libsndio7.0 libopenal1 libopenal-dev pulseaudio # bluetooth packages sudo apt install bluez-tools sudo apt install libbluetooth-dev # gstreamer (multimedia) packages sudo apt install libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc gstreamer1.0-tools gstreamer1.0-x gstreamer1.0-alsa gstreamer1.0-gl gstreamer1.0-gtk3 gstreamer1.0-qt5 gstreamer1.0-pulseaudio sudo apt install libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev","title":"9. Additional packages (Optional)"},{"location":"fenice-steeringwheel/development/qt/#10-create-directory-for-qt-deployment","text":"Now we create directories where the built QT Binaries will be deployed to your the Rasberry Pi, with following commands: sudo mkdir /usr/local/qt5.15 sudo chown -R pi:pi /usr/local/qt5.15 Also don\u2019t forget to setup Important Symlinks as follows: (Important) sudo ln -sf -r /usr/include/arm-linux-gnueabihf/asm /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/gnu /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/bits /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/sys /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/openssl /usr/include sudo ln -sf /usr/lib/arm-linux-gnueabihf/crtn.o /usr/lib/crtn.o sudo ln -sf /usr/lib/arm-linux-gnueabihf/crt1.o /usr/lib/crt1.o sudo ln -sf /usr/lib/arm-linux-gnueabihf/crti.o /usr/lib/crti.o That\u2019s it for Raspberry Pi setup.","title":"10. Create directory for QT Deployment"},{"location":"fenice-steeringwheel/development/qt/#setup-the-host-machine","text":"Now Raspberry Pi Side all setup, Let\u2019s focus on commands for our Host Machine, i.e. PC/Laptop, where you going to cross-compile the QT Binaries for your Raspberry Pi. Important: Make sure your Raspberry Pi and this Host machine (where you cross-compiling) MUST be on the SAME Network.","title":"Setup the Host Machine"},{"location":"fenice-steeringwheel/development/qt/#1-update-the-host-machine","text":"First of all, Run the following commands to update your system and install important dependancies: sudo apt update sudo apt dist-upgrade sudo apt install build-essential cmake unzip gfortran sudo apt install gcc git bison python gperf pkg-config gdb-multiarch wget sudo apt-get -y install gcc g++ gperf flex texinfo gawk bison openssl pigz libncurses-dev autoconf automake tar figlet","title":"1. Update the Host Machine"},{"location":"fenice-steeringwheel/development/qt/#2-setting-up-the-directory-structure","text":"You can use these following commands to create \u201crpi-qt\u201d to use as workspace for building QT Binaries: sudo mkdir ~/rpi-qt sudo mkdir ~/rpi-qt/build sudo mkdir ~/rpi-qt/tools sudo mkdir ~/rpi-qt/sysroot sudo mkdir ~/rpi-qt/sysroot/usr sudo mkdir ~/rpi-qt/sysroot/opt sudo chown -R 1000 :1000 ~/rpi-qt cd ~/rpi-qt Note: Ensure the last command should have changed your current directory to ~/rpi-qt . If not, run the last line again to make sure you are inside it, as the next steps assume you\u2019re running your commands from this directory.","title":"2. Setting up the directory structure"},{"location":"fenice-steeringwheel/development/qt/#3-download-extract-qt-source","text":"","title":"3. Download &amp; Extract QT Source"},{"location":"fenice-steeringwheel/development/qt/#a-download-binary","text":"Now, we can download the Latest source files for QT LTS (i.e. v5.15.2 ) by running following Terminal command to download the source files: sudo wget http://download.qt.io/archive/qt/5.15/5.15.2/single/qt-everywhere-src-5.15.2.tar.xz Note: You can also manually download file through browser, and place it in the ~/rpi-qt directory.","title":"A. Download Binary"},{"location":"fenice-steeringwheel/development/qt/#b-extract-binary","text":"Extract the downloaded tar file with the following command: sudo tar xfv qt-everywhere-src-5.15.2.tar.xz","title":"B. Extract Binary"},{"location":"fenice-steeringwheel/development/qt/#4-patching-qt-source","text":"We need to slightly modify the a mkspec file within the source files to allow us to use our cross compiler. We will copy an existing directory within the source files, and modify the name of the directory and the contents of the qmake.conf file within that directory to follow the name of our compiler. To do this, run the following two command: cp -R qt-everywhere-src-5.15.2/qtbase/mkspecs/linux-arm-gnueabi-g++ qt-everywhere-src-5.15.2/qtbase/mkspecs/linux-arm-gnueabihf-g++ sed -i -e 's/arm-linux-gnueabi-/arm-linux-gnueabihf-/g' qt-everywhere-src-5.15.2/qtbase/mkspecs/linux-arm-gnueabihf-g++/qmake.conf","title":"4. Patching QT Source"},{"location":"fenice-steeringwheel/development/qt/#5-download-extract-the-precompiled-cross-compiler","text":"Let\u2019s first change into tools directory for downloading our Precompiled Cross-compiler with the following command: cd ~/rpi-qt/tools Note: Ensure the last command should have changed your current directory to ~/rpi-qt/tools now. If not, run it again.","title":"5. Download &amp; Extract the Precompiled Cross-Compiler"},{"location":"fenice-steeringwheel/development/qt/#a-copy-binary-url","text":"Copy URL from one of following Precompiled Compressed Base-Toolchain (for maximum compatability) based on your Raspberry Pi Variant and OS you installed on it, from below: .. list-table:: :widths: 25 25 50 :header-rows: 1 * - Raspberry Pi Board - Stretch(32-bit) OS - Buster(32-bit) OS * - Raspberry Pi - *Zero/W/WH & 1 Model A/B/A+/B+* - https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Stretch/GCC%206.3.0/Raspberry%20Pi%201%2C%20Zero/cross-gcc-6.3.0-pi_0-1.tar.gz - https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%201%2C%20Zero/cross-gcc-8.3.0-pi_0-1.tar.gz * - Raspberry Pi - *2 & 3 Model A/B* - https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Stretch/GCC%206.3.0/Raspberry%20Pi%202%2C%203/cross-gcc-6.3.0-pi_2-3.tar.gz - https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%202%2C%203/cross-gcc-8.3.0-pi_2-3.tar.gz * - Raspberry Pi - *3 & 4 Model A+/B+ & Compute 3/3-lite/3+* - https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Stretch/GCC%206.3.0/Raspberry%20Pi%203A%2B%2C%203B%2B%2C%204/cross-gcc-6.3.0-pi_3%2B.tar.gz - https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%203A%2B%2C%203B%2B%2C%204/cross-gcc-8.3.0-pi_3%2B.tar.gz Note: You can also use the latest cross-compiler binaries instead. But they are not tested.","title":"A. Copy Binary URL"},{"location":"fenice-steeringwheel/development/qt/#b-download-binary","text":"After that, paste your copied URL and run the following command to download the Cross-compiler: wget <Copied Binary URL goes here> #for e.g. => wget https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%202%2C%203/cross-gcc-8.3.0-pi_2-3.tar.gz","title":"B. Download Binary"},{"location":"fenice-steeringwheel/development/qt/#c-extract-binary","text":"Once it is downloaded, we can extract it using the following command: tar xf cross-gcc-*.tar.gz","title":"C. Extract Binary"},{"location":"fenice-steeringwheel/development/qt/#6-sync-raspberry-pi-sysroot-most-important","text":"First, let\u2019s move back into the rpi folder as needed for the next sections: cd ~/rpi-qt Now, we need to sync up our sysroot folder with the system files from the Raspberry Pi. We will be using rsync that let us sync (i.e. copy) files from the Raspberry Pi with appropriate permission onto your Host Machine, potentially saving you alot of time. To do this, enter the following commands one by one into your terminal (change ``192.168.1.47`` with the IP address of your Raspberry Pi present on the same network) : Command 1: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/lib sysroot Command 2: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/usr/include sysroot/usr Command 3: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/usr/lib sysroot/usr Command 4: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/opt/vc sysroot/opt Note: Double check after each of the above commands that all the files have been copied to ~/rpi-qt/sysroot folder. There will be an information message if there were any issues.","title":"6. Sync Raspberry Pi sysroot (Most Important)"},{"location":"fenice-steeringwheel/development/qt/#7-fix-symbolic-links","text":"The files we copied in the previous step still have symbolic links pointing to the file system on the Raspberry Pi. We need to alter this so that they become relative links from the new sysroot directory on the host machine. We can do this with a python script, which we can download as follows: wget https://raw.githubusercontent.com/abhiTronix/rpi_rootfs/master/scripts/sysroot-relativelinks.py Once it is downloaded, you just need to make it executable and run it, using the following commands: sudo chmod +x sysroot-relativelinks.py ./sysroot-relativelinks.py sysroot","title":"7. Fix symbolic links"},{"location":"fenice-steeringwheel/development/qt/#8-configure-qt-build","text":"Let\u2019s move into the build directory for further steps, as we don\u2019t want to build within that source directory as its crowded, so we will access it from within this this directory: cd ~/rpi-qt/build Finally, Now we can configure our QT build. We need to run the configure script inside QT source to configure our build. Run following command to configure the build, including all the necessary options: CROSS_COMPILER_LOCATION = $HOME /rpi-qt/tools/cross-pi-gcc-* ../qt-everywhere-src-5.15.2/configure -release -opengl es2 -eglfs -device linux-rasp-pi4-v3d-g++ -device-option CROSS_COMPILE = $( echo $CROSS_COMPILER_LOCATION ) /bin/arm-linux-gnueabihf- -sysroot ~/rpi-qt/sysroot/ -prefix /usr/local/qt5.15 -extprefix ~/rpi-qt/qt5.15 -opensource -confirm-license -skip qtscript -skip qtwayland -skip qtwebengine -nomake tests -make libs -pkg-config -no-use-gold-linker -v -recheck -L $HOME /rpi-qt/sysroot/usr/lib/arm-linux-gnueabihf -I $HOME /rpi-qt/sysroot/usr/include/arm-linux-gnueabihf The configure script may take a few minutes to complete.","title":"8. Configure QT Build"},{"location":"fenice-steeringwheel/development/qt/#81-check-configure-output","text":"Once it is completed you should get a summary of what has been configured. Make sure the following options appear: Configure summary: Building on: linux-g++ ( x86_64, CPU features: mmx sse sse2 ) Building for : devices/linux-rasp-pi4-v3d-g++ ( arm, CPU features: neon ) Target compiler: gcc 8 .3.0 Configuration: cross_compile compile_examples enable_new_dtags largefile neon precompile_header shared shared rpath release c++11 c++14 c++17 c++1z concurrent dbus reduce_exports stl","title":"8.1 Check Configure Output"},{"location":"fenice-steeringwheel/development/qt/#82-check-if-eglfs-enabled","text":"QPA backends: EGLFS .................................. yes [ SHOULD BE YES ] EGLFS details: EGLFS OpenWFD ........................ no EGLFS i.Mx6 .......................... no EGLFS i.Mx6 Wayland .................. no EGLFS RCAR ........................... no EGLFS EGLDevice ...................... yes [ SHOULD BE YES ] EGLFS GBM ............................ yes EGLFS VSP2 ........................... no EGLFS Mali ........................... no EGLFS Raspberry Pi ................... no [ SHOULD BE NO ] EGLFS X11 ............................ yes If the your configuration summary doesn\u2019t have the EGLFS features set to what\u2019s shown above, something has probably gone wrong. You can look at the config.log file in the build directory to try and diagnose what the issue might be. If all looks good and all libraries you need have been installed we can continue to the next section","title":"8.2 Check if EGLFS enabled"},{"location":"fenice-steeringwheel/development/qt/#9-build-qt-source","text":"Our build has been configured now, and it is time to actually build the source files, and run the following command: Important: Ensure you are still in the ~/rpi-qt/build directory make -j $( nproc ) Note: -j$(nproc) option indicates that the job should be spread into mutliple threads and run in parallel on available cores. \u2615\ufe0f This process will take some time!","title":"9. Build QT Source"},{"location":"fenice-steeringwheel/development/qt/#10-install-qt-source","text":"Once it is completed, we can install the built package using the following command: make install This should install the files in the correct directories","title":"10. Install QT Source"},{"location":"fenice-steeringwheel/development/qt/#11-deploy-qt-to-raspberry-pi","text":"First move back into the rpi folder using the following command: cd ~/rpi-qt Now, We can now deploy built QT Binaries (contained in ``qt5.15`` folder in ``~/rpi-qt`` directory) back to our Raspberry Pi, again using rsync command. Just run the following command (change ``192.168.1.47`` with the IP address of your Raspberry Pi present on the same network) : rsync -avz --rsync-path = \"sudo rsync\" qt5.15 pi@192.168.1.47:/usr/local","title":"11. Deploy QT to Raspberry Pi"},{"location":"fenice-steeringwheel/development/qt/#final-step-for-target-machine","text":"","title":"Final Step for Target Machine"},{"location":"fenice-steeringwheel/development/qt/#update-linker-on-raspberry-pi","text":"Enter the following command to update the device letting the linker to find the new QT binary files: echo /usr/local/qt5.15/lib | sudo tee /etc/ld.so.conf.d/qt5.15.conf sudo ldconfig For Raspberry Pi 2: If you\u2019re facing issues with running the example, try to use 00-qt5pi.conf instead of qt5pi.conf , in the above command. \ud83c\udf7b That should be it! You have now succesfully installed latest QT 5.15.2 on the Raspberry Pi.","title":"Update linker on Raspberry Pi"},{"location":"fenice-steeringwheel/interface/tabs/","text":"Concept of Tabs","title":"Concept of Tabs"},{"location":"fenice-steeringwheel/interface/tabs/#concept-of-tabs","text":"","title":"Concept of Tabs"},{"location":"handcart/main/","text":"Handcart Documentation Intro The handcart is the device that is responsible of transporting and charging the car's accumulator. It is based on three main components: Brusa NLG513 charger, that is the actual charger Raspberry pi 4 to run the software High Voltage Accumulator The rasp is connected via CAN Bus with the BMS in the accumulator and with the Brusa charger. The software of the handcart is responsible of all the processes to ensure a good and safe charge. Abbreviations BMS, porco, acc -> accumulator HV -> High Voltage rasp -> raspberry Software Overview Backend Frontend Brusa NLG513 Hardware Electrical wiring Handcart PCB","title":"Handcart Documentation"},{"location":"handcart/main/#handcart-documentation","text":"","title":"Handcart Documentation"},{"location":"handcart/main/#intro","text":"The handcart is the device that is responsible of transporting and charging the car's accumulator. It is based on three main components: Brusa NLG513 charger, that is the actual charger Raspberry pi 4 to run the software High Voltage Accumulator The rasp is connected via CAN Bus with the BMS in the accumulator and with the Brusa charger. The software of the handcart is responsible of all the processes to ensure a good and safe charge.","title":"Intro"},{"location":"handcart/main/#abbreviations","text":"BMS, porco, acc -> accumulator HV -> High Voltage rasp -> raspberry","title":"Abbreviations"},{"location":"handcart/main/#software","text":"","title":"Software"},{"location":"handcart/main/#overview","text":"","title":"Overview"},{"location":"handcart/main/#backend","text":"","title":"Backend"},{"location":"handcart/main/#frontend","text":"","title":"Frontend"},{"location":"handcart/main/#brusa-nlg513","text":"","title":"Brusa NLG513"},{"location":"handcart/main/#hardware","text":"","title":"Hardware"},{"location":"handcart/main/#electrical-wiring","text":"","title":"Electrical wiring"},{"location":"handcart/main/#handcart-pcb","text":"","title":"Handcart PCB"},{"location":"wiki/","text":"E-Agle TRT Wiki","title":"E-Agle TRT Wiki"},{"location":"wiki/#e-agle-trt-wiki","text":"","title":"E-Agle TRT Wiki"},{"location":"wiki/common/openocd-errors/","text":"OpenOCD errors Error connecting DP: cannot read IDR CONDITIONS The following conditions can be observed by using a DAPlink programmer. Enable debug mode level >0 for openOCD, this can be done either via: openocd -d3 ...other_parameters... If using the extension cortex-debug in VSCode, by adding: in file openocd.cfg ------- debug_level 3 If the output of openocd contains: Debug: 229 931 cmsis_dap.c:646 cmsis_dap_swd_read_process(): SWD ack not OK @ 0 JUNK Error: 230 932 adi_v5_swd.c:144 swd_connect(): Error connecting DP: cannot read IDR Debug: 231 932 command.c:628 run_command(): Command 'dap init' failed with error code -4 User : 232 932 command.c:694 command_run_line(): Then the problem is likely to be hardware, i.e. the programmer (DAPlink) is unable to connect/talk to the target via SWD. See this mailling list thread. SOLUTION Check VDD voltages: Do they reach the micro? Are they the correct value? Are there short-circuits to GND ? Check continuity on SWDIO and SWCLK lines Are the mircos' pins soldered to the board? Is the micro correctly oriented on the pcb? Check the DAP connection Do the jumper-wires work?","title":"OpenOCD errors"},{"location":"wiki/common/openocd-errors/#openocd-errors","text":"","title":"OpenOCD errors"},{"location":"wiki/common/openocd-errors/#error-connecting-dp-cannot-read-idr","text":"","title":"Error connecting DP: cannot read IDR"},{"location":"wiki/common/openocd-errors/#conditions","text":"The following conditions can be observed by using a DAPlink programmer. Enable debug mode level >0 for openOCD, this can be done either via: openocd -d3 ...other_parameters... If using the extension cortex-debug in VSCode, by adding: in file openocd.cfg ------- debug_level 3 If the output of openocd contains: Debug: 229 931 cmsis_dap.c:646 cmsis_dap_swd_read_process(): SWD ack not OK @ 0 JUNK Error: 230 932 adi_v5_swd.c:144 swd_connect(): Error connecting DP: cannot read IDR Debug: 231 932 command.c:628 run_command(): Command 'dap init' failed with error code -4 User : 232 932 command.c:694 command_run_line(): Then the problem is likely to be hardware, i.e. the programmer (DAPlink) is unable to connect/talk to the target via SWD. See this mailling list thread.","title":"CONDITIONS"},{"location":"wiki/common/openocd-errors/#solution","text":"Check VDD voltages: Do they reach the micro? Are they the correct value? Are there short-circuits to GND ? Check continuity on SWDIO and SWCLK lines Are the mircos' pins soldered to the board? Is the micro correctly oriented on the pcb? Check the DAP connection Do the jumper-wires work?","title":"SOLUTION"},{"location":"wiki/common/about/introduction/","text":"Introduction","title":"Introduction"},{"location":"wiki/common/about/introduction/#introduction","text":"","title":"Introduction"},{"location":"wiki/common/about/writing-docs/","text":"Writing Documentation Testing the documentation locally You can test locally the exported documentation using the custom docker image generated by the wiki project. Open a terminal in the root folder of your project Make sure the docs/ folder is present Run this command: docker run --rm \\ -p 8000 :8000 \\ -v $( pwd ) /docs:/wiki/docs/<project-name>:z \\ eagletrt/wiki Tip Live reloading works when testing with docker. Notes and warnings !!! note This this a note. Note This this a note. !!! warning This this a warning. Warning This this a warning. Supported types are: note abstract , summary , tldr info , todo tip , hint , important success , check , done question , help , faq warning , caution , attention faliure , fail , missing danger , error bug example quote , cite Mathematical expressions $x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$ \\(x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.\\) Embedding PDFs < object data = \"../sample.pdf\" type = \"application/pdf\" style = \"width: 100%; height: 600px\" > < embed src = \"../sample.pdf\" type = \"application/pdf\" /> </ object >","title":"Writing Documentation"},{"location":"wiki/common/about/writing-docs/#writing-documentation","text":"","title":"Writing Documentation"},{"location":"wiki/common/about/writing-docs/#testing-the-documentation-locally","text":"You can test locally the exported documentation using the custom docker image generated by the wiki project. Open a terminal in the root folder of your project Make sure the docs/ folder is present Run this command: docker run --rm \\ -p 8000 :8000 \\ -v $( pwd ) /docs:/wiki/docs/<project-name>:z \\ eagletrt/wiki Tip Live reloading works when testing with docker.","title":"Testing the documentation locally"},{"location":"wiki/common/about/writing-docs/#notes-and-warnings","text":"!!! note This this a note. Note This this a note. !!! warning This this a warning. Warning This this a warning. Supported types are: note abstract , summary , tldr info , todo tip , hint , important success , check , done question , help , faq warning , caution , attention faliure , fail , missing danger , error bug example quote , cite","title":"Notes and warnings"},{"location":"wiki/common/about/writing-docs/#mathematical-expressions","text":"$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$ \\(x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.\\)","title":"Mathematical expressions"},{"location":"wiki/common/about/writing-docs/#embedding-pdfs","text":"< object data = \"../sample.pdf\" type = \"application/pdf\" style = \"width: 100%; height: 600px\" > < embed src = \"../sample.pdf\" type = \"application/pdf\" /> </ object >","title":"Embedding PDFs"}]}