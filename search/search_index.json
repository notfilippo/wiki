{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"E-Agle TRT Wiki","title":"E-Agle TRT Wiki"},{"location":"#e-agle-trt-wiki","text":"","title":"E-Agle TRT Wiki"},{"location":"common/about/writing-docs/","text":"Writing Documentation Testing the documentation locally You can test locally the exported documentation using the custom docker image generated by the wiki project. Open a terminal in the root folder of your project Make sure the docs/ folder is present Fetch the documentation image: docker pull eagletrt/wiki:latest Run the autoreloading documentation: docker run --rm \\ -p 8000 :8000 \\ -v $( pwd ) /docs:/wiki/docs/<project-name>:z \\ eagletrt/wiki Tip Live reloading works when testing with docker. Ordering pages You can change the order and titles of your pages by configuring a .pages file anywhere in your documentation file tree. For more information on the file format take a look at the official documentation . title: Example nav: - subdirectory - page1.md - page2.md Diagrams You can draw diagrams with mermaid . ```diagram stateDiagram-v2 [*] --> Still Still --> [*] Still --> Moving Moving --> Still Moving --> Crash Crash --> [*] ``` stateDiagram-v2 [*] --> Still Still --> [*] Still --> Moving Moving --> Still Moving --> Crash Crash --> [*] Notes and warnings !!! note This this a note. Note This this a note. !!! warning This this a warning. Warning This this a warning. Supported types are: note abstract , summary , tldr info , todo tip , hint , important success , check , done question , help , faq warning , caution , attention failure , fail , missing danger , error bug example quote , cite Mathematical expressions $x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$ \\(x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.\\) Embedding PDFs < object data = \"../sample.pdf\" type = \"application/pdf\" style = \"width: 100%; height: 600px\" > < embed src = \"../sample.pdf\" type = \"application/pdf\" /> </ object >","title":"Writing Documentation"},{"location":"common/about/writing-docs/#writing-documentation","text":"","title":"Writing Documentation"},{"location":"common/about/writing-docs/#testing-the-documentation-locally","text":"You can test locally the exported documentation using the custom docker image generated by the wiki project. Open a terminal in the root folder of your project Make sure the docs/ folder is present Fetch the documentation image: docker pull eagletrt/wiki:latest Run the autoreloading documentation: docker run --rm \\ -p 8000 :8000 \\ -v $( pwd ) /docs:/wiki/docs/<project-name>:z \\ eagletrt/wiki Tip Live reloading works when testing with docker.","title":"Testing the documentation locally"},{"location":"common/about/writing-docs/#ordering-pages","text":"You can change the order and titles of your pages by configuring a .pages file anywhere in your documentation file tree. For more information on the file format take a look at the official documentation . title: Example nav: - subdirectory - page1.md - page2.md","title":"Ordering pages"},{"location":"common/about/writing-docs/#diagrams","text":"You can draw diagrams with mermaid . ```diagram stateDiagram-v2 [*] --> Still Still --> [*] Still --> Moving Moving --> Still Moving --> Crash Crash --> [*] ``` stateDiagram-v2 [*] --> Still Still --> [*] Still --> Moving Moving --> Still Moving --> Crash Crash --> [*]","title":"Diagrams"},{"location":"common/about/writing-docs/#notes-and-warnings","text":"!!! note This this a note. Note This this a note. !!! warning This this a warning. Warning This this a warning. Supported types are: note abstract , summary , tldr info , todo tip , hint , important success , check , done question , help , faq warning , caution , attention failure , fail , missing danger , error bug example quote , cite","title":"Notes and warnings"},{"location":"common/about/writing-docs/#mathematical-expressions","text":"$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$ \\(x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.\\)","title":"Mathematical expressions"},{"location":"common/about/writing-docs/#embedding-pdfs","text":"< object data = \"../sample.pdf\" type = \"application/pdf\" style = \"width: 100%; height: 600px\" > < embed src = \"../sample.pdf\" type = \"application/pdf\" /> </ object >","title":"Embedding PDFs"},{"location":"common/shared/openocd-errors/","text":"OpenOCD errors Error connecting DP: cannot read IDR CONDITIONS The following conditions can be observed by using a DAPlink programmer. Enable debug mode level >0 for openOCD, this can be done either via: openocd -d3 ...other_parameters... If using the extension cortex-debug in VSCode, by adding: in file openocd.cfg ------- debug_level 3 If the output of openocd contains: Debug: 229 931 cmsis_dap.c:646 cmsis_dap_swd_read_process(): SWD ack not OK @ 0 JUNK Error: 230 932 adi_v5_swd.c:144 swd_connect(): Error connecting DP: cannot read IDR Debug: 231 932 command.c:628 run_command(): Command 'dap init' failed with error code -4 User : 232 932 command.c:694 command_run_line(): Then the problem is likely to be hardware, i.e. the programmer (DAPlink) is unable to connect/talk to the target via SWD. See this mailling list thread. SOLUTION Check VDD voltages: Do they reach the micro? Are they the correct value? Are there short-circuits to GND ? Check continuity on SWDIO and SWCLK lines Are the mircos' pins soldered to the board? Is the micro correctly oriented on the pcb? Check the DAP connection Do the jumper-wires work?","title":"OpenOCD errors"},{"location":"common/shared/openocd-errors/#openocd-errors","text":"","title":"OpenOCD errors"},{"location":"common/shared/openocd-errors/#error-connecting-dp-cannot-read-idr","text":"","title":"Error connecting DP: cannot read IDR"},{"location":"common/shared/openocd-errors/#conditions","text":"The following conditions can be observed by using a DAPlink programmer. Enable debug mode level >0 for openOCD, this can be done either via: openocd -d3 ...other_parameters... If using the extension cortex-debug in VSCode, by adding: in file openocd.cfg ------- debug_level 3 If the output of openocd contains: Debug: 229 931 cmsis_dap.c:646 cmsis_dap_swd_read_process(): SWD ack not OK @ 0 JUNK Error: 230 932 adi_v5_swd.c:144 swd_connect(): Error connecting DP: cannot read IDR Debug: 231 932 command.c:628 run_command(): Command 'dap init' failed with error code -4 User : 232 932 command.c:694 command_run_line(): Then the problem is likely to be hardware, i.e. the programmer (DAPlink) is unable to connect/talk to the target via SWD. See this mailling list thread.","title":"CONDITIONS"},{"location":"common/shared/openocd-errors/#solution","text":"Check VDD voltages: Do they reach the micro? Are they the correct value? Are there short-circuits to GND ? Check continuity on SWDIO and SWCLK lines Are the mircos' pins soldered to the board? Is the micro correctly oriented on the pcb? Check the DAP connection Do the jumper-wires work?","title":"SOLUTION"},{"location":"fenice-bms-hv-sw/","text":"High-Voltage Battery Management System Battery management is a collection of operations that ensure the safety and efficiency of the battery pack. A basic battery management system should constantly measure cell temperatures and voltages along with the total pack current output and check that each of those values is within specification. If anomalies are detected, the battery should be disconnected immediately via the AIRs. A good battery management system is also able to keep the battery in good operating conditions, with the goal of maintaining the expected efficiency of the powertrain. The need of collecting a lot of data from all over the pack has dictated a scattered architecture for the BMS, that uses multiple data acquisition boards (cellboards) and a single control board (mainboard).","title":"High-Voltage Battery Management System"},{"location":"fenice-bms-hv-sw/#high-voltage-battery-management-system","text":"Battery management is a collection of operations that ensure the safety and efficiency of the battery pack. A basic battery management system should constantly measure cell temperatures and voltages along with the total pack current output and check that each of those values is within specification. If anomalies are detected, the battery should be disconnected immediately via the AIRs. A good battery management system is also able to keep the battery in good operating conditions, with the goal of maintaining the expected efficiency of the powertrain. The need of collecting a lot of data from all over the pack has dictated a scattered architecture for the BMS, that uses multiple data acquisition boards (cellboards) and a single control board (mainboard).","title":"High-Voltage Battery Management System"},{"location":"fenice-bms-hv-sw/mainboard/","text":"Mainboard The Mainboard is the central control unit of the BMS. It contains a microcontroller that handles two CAN-bus lines for internal and external communications, peripherals such as insulated ADCs, EEPROMs, serial ports, an SD-card and more. The mainboard is responsible for the actuation of the AIRs and contains the shutdown and pre-charge circuits. It also communicates voltages, temperatures, currents, battery status, warnings and errors to the rest of the car via CAN-bus. An integrated serial command-line interface and internal logging are included to help with troubleshooting. The logic of the mainboard is handled by a couple of finite state machines (FSM). The fsm library is used to manage every state machine of the BMS. Subsystems There are several subsystems to the Mainboard's firmware: bal : The bal subsystem contains functions of the cell balancing algorithm bal_fsm : The FSM of the balancing algorithm is contained here bms_fsm : The BMS fsm handles the main state machine of the board. It is responsible for the management of the tractive system activation and deactivation. cli_bms : All the CLI commands are defined here. config : Generic interface to handle all sorts of configurations current : Current measurement functions energy : Energy measurement and State-of-Charge estimation logic. feedback : Mainboard's feedbacks handler functions and variables pack : Old interface for the battery pack. soc : State of charge estimation functions. super_fsm : A super FSM that encloses the bms_fsm and measurement routines.","title":"Mainboard"},{"location":"fenice-bms-hv-sw/mainboard/#mainboard","text":"The Mainboard is the central control unit of the BMS. It contains a microcontroller that handles two CAN-bus lines for internal and external communications, peripherals such as insulated ADCs, EEPROMs, serial ports, an SD-card and more. The mainboard is responsible for the actuation of the AIRs and contains the shutdown and pre-charge circuits. It also communicates voltages, temperatures, currents, battery status, warnings and errors to the rest of the car via CAN-bus. An integrated serial command-line interface and internal logging are included to help with troubleshooting. The logic of the mainboard is handled by a couple of finite state machines (FSM). The fsm library is used to manage every state machine of the BMS.","title":"Mainboard"},{"location":"fenice-bms-hv-sw/mainboard/#subsystems","text":"There are several subsystems to the Mainboard's firmware: bal : The bal subsystem contains functions of the cell balancing algorithm bal_fsm : The FSM of the balancing algorithm is contained here bms_fsm : The BMS fsm handles the main state machine of the board. It is responsible for the management of the tractive system activation and deactivation. cli_bms : All the CLI commands are defined here. config : Generic interface to handle all sorts of configurations current : Current measurement functions energy : Energy measurement and State-of-Charge estimation logic. feedback : Mainboard's feedbacks handler functions and variables pack : Old interface for the battery pack. soc : State of charge estimation functions. super_fsm : A super FSM that encloses the bms_fsm and measurement routines.","title":"Subsystems"},{"location":"fenice-bms-hv-sw/mainboard/io/","text":"I/O There are many peripherals and devices connected to the mainboard. Every component that interfaces with the mainboard's microcontroller is listed here: CAN-buses (CAN): A CAN-bus to communicate with the car and an internal isolated bus for handling the cellboards. Si8900 isolated ADC (UART): Used to measure pack and bus voltages, and is also used to measure the pack current using a shunt resistor. DAHB S/160 Hall-effect sensor (ADC): Used to measure pack current. Less precise than the shunt, included for historic reasons. The unit contains two sensors with different gains to have a broader current range. AIR and pre-charge controls : Three output pins control the actuation of the AIRs (if the shutdown circuit is not latched in the off state) and the pre-charge circuit. Circuit feedbacks (MUX/ADC): 16 multiplexed analog signals coming from the mainboard's circuit. Used to diagnose the circuit and to verify its correct state compared to the BMS state. Some of those feedbacks are not multiplexed to permit the generation of interrupts from them. IMD Status (PWM): The IMD has an output PWM signal that reports its internal state. M95256 EEPROM (SPI): Used to store runtime variables and data, such as state of charge information, balancing threshold and more. SD-card (SPI): An SD-card is included on the mainboard to be used as storage for extended logs. User console (UART): A serial interface is reserved as an user interface to read/write data and execute commands. The cli library is used as an interface. GPIOs : 9 GPIO pins for external stuff.","title":"I/O"},{"location":"fenice-bms-hv-sw/mainboard/io/#io","text":"There are many peripherals and devices connected to the mainboard. Every component that interfaces with the mainboard's microcontroller is listed here: CAN-buses (CAN): A CAN-bus to communicate with the car and an internal isolated bus for handling the cellboards. Si8900 isolated ADC (UART): Used to measure pack and bus voltages, and is also used to measure the pack current using a shunt resistor. DAHB S/160 Hall-effect sensor (ADC): Used to measure pack current. Less precise than the shunt, included for historic reasons. The unit contains two sensors with different gains to have a broader current range. AIR and pre-charge controls : Three output pins control the actuation of the AIRs (if the shutdown circuit is not latched in the off state) and the pre-charge circuit. Circuit feedbacks (MUX/ADC): 16 multiplexed analog signals coming from the mainboard's circuit. Used to diagnose the circuit and to verify its correct state compared to the BMS state. Some of those feedbacks are not multiplexed to permit the generation of interrupts from them. IMD Status (PWM): The IMD has an output PWM signal that reports its internal state. M95256 EEPROM (SPI): Used to store runtime variables and data, such as state of charge information, balancing threshold and more. SD-card (SPI): An SD-card is included on the mainboard to be used as storage for extended logs. User console (UART): A serial interface is reserved as an user interface to read/write data and execute commands. The cli library is used as an interface. GPIOs : 9 GPIO pins for external stuff.","title":"I/O"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bal/","text":"Cell Balancing The cell balancing operation is mostly done on the cellboards. However, the mainboard has to compute all the cells that need to be discharged. To synchronize cellboards and the mainboard an FSM is defined: stateDiagram-v2 direction LR [*] --> OFF OFF --> CMP OFF --> OFF CMP --> DSC CMP --> OFF DSC --> COOL DSC --> OFF DSC --> DSC COOL --> CMP COOL--> OFF COOL --> COOL - Off (OFF) The dormant state of the balancing algorithm. - Compute (CMP) Compute phase. This is where the cell selection algorithm is run. If no cells need to be discharged the FSM returns back to the Off state. The compute phase can be triggered manually via the CLI. The algorithm is split in two phases: Imbalance computation The imbalance is the voltage difference between a given cell and the minimum-voltage cell. In this phase an imbalance array that contains the imbalances of every cell is created. In this case the imbalance is centered around the minimum-voltage plus a threshold, that is the maximum imbalance permitted in the pack. \\(imbalance[i] = \\max(0, voltages[i] \u2212(min\\_voltage + threshold))\\) Cell selection The cell selection algorithm is very similar to the Hateville problem ( video ) discussed in the ASD course. The purpose of this phase is to select the best subset of non-adjacent cells that need to be discharged. This step runs on every cellboard, after the list of cells to discharge is received. A thesis further explains the implementation of this algorithm. - Discharge (DSC) After compute the mainboard sends the list of cells to be discharged to the cellboards that start the actual discharge for a set amount of time. The discharge time depends on configuration but it's in the range from 30 to 120s. - Cooldown (COOL) Cooldown. A small period (5-10s) where voltages are","title":"Cell Balancing"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bal/#cell-balancing","text":"The cell balancing operation is mostly done on the cellboards. However, the mainboard has to compute all the cells that need to be discharged. To synchronize cellboards and the mainboard an FSM is defined: stateDiagram-v2 direction LR [*] --> OFF OFF --> CMP OFF --> OFF CMP --> DSC CMP --> OFF DSC --> COOL DSC --> OFF DSC --> DSC COOL --> CMP COOL--> OFF COOL --> COOL","title":"Cell Balancing"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bal/#-off-off","text":"The dormant state of the balancing algorithm.","title":"- Off (OFF)"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bal/#-compute-cmp","text":"Compute phase. This is where the cell selection algorithm is run. If no cells need to be discharged the FSM returns back to the Off state. The compute phase can be triggered manually via the CLI. The algorithm is split in two phases:","title":"- Compute (CMP)"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bal/#imbalance-computation","text":"The imbalance is the voltage difference between a given cell and the minimum-voltage cell. In this phase an imbalance array that contains the imbalances of every cell is created. In this case the imbalance is centered around the minimum-voltage plus a threshold, that is the maximum imbalance permitted in the pack. \\(imbalance[i] = \\max(0, voltages[i] \u2212(min\\_voltage + threshold))\\)","title":"Imbalance computation"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bal/#cell-selection","text":"The cell selection algorithm is very similar to the Hateville problem ( video ) discussed in the ASD course. The purpose of this phase is to select the best subset of non-adjacent cells that need to be discharged. This step runs on every cellboard, after the list of cells to discharge is received. A thesis further explains the implementation of this algorithm.","title":"Cell selection"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bal/#-discharge-dsc","text":"After compute the mainboard sends the list of cells to be discharged to the cellboards that start the actual discharge for a set amount of time. The discharge time depends on configuration but it's in the range from 30 to 120s.","title":"- Discharge (DSC)"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bal/#-cooldown-cool","text":"Cooldown. A small period (5-10s) where voltages are","title":"- Cooldown (COOL)"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/","text":"Command Line Interface The command line interface of the Mainboard is based on the cli library. It serves as the main interface with the BMS. The CLI is clocked at 115200 baud and uses local echo Warning The CLI runs on UART1, thus it is not compatible with STM32 Nucleo boards that normally use UART2 as the USB serial console. As the name implies, the CLI is based around commands, in a style inspired by Unix consoles. Pressing ? followed by Enter will give a list of legal commands. Commands volt The volt command returns the main voltages of the battery pack. Example bus.......0.00 V internal..388.8 V average...3.60 V max.......3.70 V min.......3.50 V delta.....0.20 V Parameters all : prints all cell voltages. temp Similarly to the volt command, temp will return the main temperatures of the pack. Parameters all : Prints all battery temperatures. status Returns a summary of the general status of the BMS. errors This command will return a list containing each active errors and its details ts Controls the Tractive System actuation. Parameters on : generates a TS_ON event on the BMS FSM . off : triggers TS_OFF event on the aforementioned FSM. bal Suite of commands that handle the balancing process. Parameters on : Triggers an event that enables the BAL FSM . off : Triggers an event that disables balancing. thr : Returns the currently set threshold. thr <millivolts> : Sets the threshold to the value of <millivolts> . Please be gentle with it: it can break bad if you input strange stuff soc Return state of charge information Parameters reset : resets the 'last charge' energy meter. current Shows current measurement for all the available sensors. Parameters zero : zeroes the Hall-effect sensors. dmesg Toggles the debug output. This can be quite verbose if enabled. reset Resets the microcontroller. Analogue to pressing the reset button on board. Easter eggs? Of course","title":"Command Line Interface"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#command-line-interface","text":"The command line interface of the Mainboard is based on the cli library. It serves as the main interface with the BMS. The CLI is clocked at 115200 baud and uses local echo Warning The CLI runs on UART1, thus it is not compatible with STM32 Nucleo boards that normally use UART2 as the USB serial console. As the name implies, the CLI is based around commands, in a style inspired by Unix consoles. Pressing ? followed by Enter will give a list of legal commands.","title":"Command Line Interface"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#commands","text":"","title":"Commands"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#volt","text":"The volt command returns the main voltages of the battery pack. Example bus.......0.00 V internal..388.8 V average...3.60 V max.......3.70 V min.......3.50 V delta.....0.20 V","title":"volt"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#parameters","text":"all : prints all cell voltages.","title":"Parameters"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#temp","text":"Similarly to the volt command, temp will return the main temperatures of the pack.","title":"temp"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#parameters_1","text":"all : Prints all battery temperatures.","title":"Parameters"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#status","text":"Returns a summary of the general status of the BMS.","title":"status"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#errors","text":"This command will return a list containing each active errors and its details","title":"errors"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#ts","text":"Controls the Tractive System actuation.","title":"ts"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#parameters_2","text":"on : generates a TS_ON event on the BMS FSM . off : triggers TS_OFF event on the aforementioned FSM.","title":"Parameters"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#bal","text":"Suite of commands that handle the balancing process.","title":"bal"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#parameters_3","text":"on : Triggers an event that enables the BAL FSM . off : Triggers an event that disables balancing. thr : Returns the currently set threshold. thr <millivolts> : Sets the threshold to the value of <millivolts> . Please be gentle with it: it can break bad if you input strange stuff","title":"Parameters"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#soc","text":"Return state of charge information","title":"soc"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#parameters_4","text":"reset : resets the 'last charge' energy meter.","title":"Parameters"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#current","text":"Shows current measurement for all the available sensors.","title":"current"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#parameters_5","text":"zero : zeroes the Hall-effect sensors.","title":"Parameters"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#dmesg","text":"Toggles the debug output. This can be quite verbose if enabled.","title":"dmesg"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#reset","text":"Resets the microcontroller. Analogue to pressing the reset button on board.","title":"reset"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#easter-eggs","text":"Of course","title":"Easter eggs?"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_fsm/","text":"Main State Machine The BMS fsm handles the main state machine of the board. It is responsible for the management of the tractive system activation and deactivation. States stateDiagram-v2 direction LR [*] --> Idle Idle --> Precharge Idle --> Error Precharge --> On Precharge --> Idle Precharge --> Error On --> Idle On --> Error Error --> Idle - Idle When the TS is off and no fatal errors are present, the BMS is in the Idle state. - Precharge The Precharge procedure is done to turn on the Tractive System. It involves the actuation of the AIRs and the monitoring of the bus voltage. In the entry phase of the precharge state, the negative AIR is closed. This initiates the precharge procedure. The bus voltage is periodically confronted with the internal voltage and when they are within 10% of each other the positive AIR is closed, ending the precharge procedure. The FSM then transitions to the TS_On state. If the bus voltage doesn't rise fast enough, the precharge fails and the FSM goes back to Idle. - TS_On In this state the high-voltage bus external to the battery is powered. This is the state in which the car can run, or the battery can be charged. When the TS_OFF event occurs, the FSM transitions back to Idle, opening both AIRs at the same time. - Error If a fatal error is active the BMS is in this state. TS activation requests are ignored. If every fatal error expires, then the BMS returns to Idle and can accept TS on commands again.","title":"Main State Machine"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_fsm/#main-state-machine","text":"The BMS fsm handles the main state machine of the board. It is responsible for the management of the tractive system activation and deactivation.","title":"Main State Machine"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_fsm/#states","text":"stateDiagram-v2 direction LR [*] --> Idle Idle --> Precharge Idle --> Error Precharge --> On Precharge --> Idle Precharge --> Error On --> Idle On --> Error Error --> Idle","title":"States"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_fsm/#-idle","text":"When the TS is off and no fatal errors are present, the BMS is in the Idle state.","title":"- Idle"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_fsm/#-precharge","text":"The Precharge procedure is done to turn on the Tractive System. It involves the actuation of the AIRs and the monitoring of the bus voltage. In the entry phase of the precharge state, the negative AIR is closed. This initiates the precharge procedure. The bus voltage is periodically confronted with the internal voltage and when they are within 10% of each other the positive AIR is closed, ending the precharge procedure. The FSM then transitions to the TS_On state. If the bus voltage doesn't rise fast enough, the precharge fails and the FSM goes back to Idle.","title":"- Precharge"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_fsm/#-ts_on","text":"In this state the high-voltage bus external to the battery is powered. This is the state in which the car can run, or the battery can be charged. When the TS_OFF event occurs, the FSM transitions back to Idle, opening both AIRs at the same time.","title":"- TS_On"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_fsm/#-error","text":"If a fatal error is active the BMS is in this state. TS activation requests are ignored. If every fatal error expires, then the BMS returns to Idle and can accept TS on commands again.","title":"- Error"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/config/","text":"Config The config subsystem is a generic configuration manager that handles the storage and retrieval of vairables from an on-board EEPROM, model m95256. The config struct contains all the needed data: struct config { uint32_t version ; uint16_t address ; bool dirty ; size_t size ; void * data ; }; version stores a version string that is used during to verify that the read data is right. By changing the version string the data gets automatically overwritten with default values. The config struct is rendered opaque by the use of the config_t type. This avoids direct access to config 's content.","title":"Config"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/config/#config","text":"The config subsystem is a generic configuration manager that handles the storage and retrieval of vairables from an on-board EEPROM, model m95256. The config struct contains all the needed data: struct config { uint32_t version ; uint16_t address ; bool dirty ; size_t size ; void * data ; }; version stores a version string that is used during to verify that the read data is right. By changing the version string the data gets automatically overwritten with default values. The config struct is rendered opaque by the use of the config_t type. This avoids direct access to config 's content.","title":"Config"},{"location":"fenice-ecu/","text":"Electronic Control Unit Fenice's ECU controls the global state of the vehicle and manages its transitions between states. For example, when the driver requests the car to enter the RUN state, the ECU will execute all needed operations and will prepare the vehicle to meet all needed constraints in order to safely move. Although its main task is rather simple, this component is actually composed of many modules. The first reason is that this apparently small state machine conceals quite a lot of abstraction, therefore needing a certain quantity of code in order to reach down to the low level of a micro-controller interface. The second reason follows from the first, meaning that all this code, in order to remain maintainable and reliable in time, needs a proper level of modularization and separation.","title":"Introduction"},{"location":"fenice-ecu/#electronic-control-unit","text":"Fenice's ECU controls the global state of the vehicle and manages its transitions between states. For example, when the driver requests the car to enter the RUN state, the ECU will execute all needed operations and will prepare the vehicle to meet all needed constraints in order to safely move. Although its main task is rather simple, this component is actually composed of many modules. The first reason is that this apparently small state machine conceals quite a lot of abstraction, therefore needing a certain quantity of code in order to reach down to the low level of a micro-controller interface. The second reason follows from the first, meaning that all this code, in order to remain maintainable and reliable in time, needs a proper level of modularization and separation.","title":"Electronic Control Unit"},{"location":"fenice-ecu/fsm/","text":"Finite State Machine Warning This document is no way definitive or contains reliable information States: Init The microcontroller is initializing its state and peripherals. Idle The ECU is ready to operate and receive inputs. Upon a TS_ON request, enter the precharge state. Precharge Send the BMS-HV a TS_ON message and wait for its precharge to complete, then enter the inv_updates_activation state. Inv. Updates Activation Ask the inverters to start reporting the contents of their status registers every 100ms. When the request is fulfilled, enter the inv_drive_activation state. Inv. Drive Activation Enable the inverters (Drive Mode) and upon confirmation enter the run state. Run Read pedal values from the PCU and forward them to the Control Unit and/or the inverters. Upon a TS_OFF request, enter the inv_drive_deactivation state. Inv. Drive Deactivation Disable the inverters and upon confirmation enter the inv_updates_deactivation state. Inv. Updates Deactivation Stop the inverters status reports and enter the discharge state. Discharge Send the BMS-HV a TS_OFF request and, upon fulfillment, enter the idle state.","title":"Finite State Machine"},{"location":"fenice-ecu/fsm/#finite-state-machine","text":"Warning This document is no way definitive or contains reliable information","title":"Finite State Machine"},{"location":"fenice-ecu/fsm/#states","text":"","title":"States:"},{"location":"fenice-ecu/fsm/#init","text":"The microcontroller is initializing its state and peripherals.","title":"Init"},{"location":"fenice-ecu/fsm/#idle","text":"The ECU is ready to operate and receive inputs. Upon a TS_ON request, enter the precharge state.","title":"Idle"},{"location":"fenice-ecu/fsm/#precharge","text":"Send the BMS-HV a TS_ON message and wait for its precharge to complete, then enter the inv_updates_activation state.","title":"Precharge"},{"location":"fenice-ecu/fsm/#inv-updates-activation","text":"Ask the inverters to start reporting the contents of their status registers every 100ms. When the request is fulfilled, enter the inv_drive_activation state.","title":"Inv. Updates Activation"},{"location":"fenice-ecu/fsm/#inv-drive-activation","text":"Enable the inverters (Drive Mode) and upon confirmation enter the run state.","title":"Inv. Drive Activation"},{"location":"fenice-ecu/fsm/#run","text":"Read pedal values from the PCU and forward them to the Control Unit and/or the inverters. Upon a TS_OFF request, enter the inv_drive_deactivation state.","title":"Run"},{"location":"fenice-ecu/fsm/#inv-drive-deactivation","text":"Disable the inverters and upon confirmation enter the inv_updates_deactivation state.","title":"Inv. Drive Deactivation"},{"location":"fenice-ecu/fsm/#inv-updates-deactivation","text":"Stop the inverters status reports and enter the discharge state.","title":"Inv. Updates Deactivation"},{"location":"fenice-ecu/fsm/#discharge","text":"Send the BMS-HV a TS_OFF request and, upon fulfillment, enter the idle state.","title":"Discharge"},{"location":"fenice-ecu/modules/","text":"Modules UART Four devices make use of serial communication: a textual UART for debugging messages, two wheel encoders, and one steering encoder. Among these, however, only the debugging UART is directly interfaced with the STM serial controller: Interface TX Pin RX Pin Baud Rate Description UART4 PA12 PA13 115200 Debugging messages The serial signal from the wheel encoders instead, is decoded by transceivers on the DAS board that, in turn, feed two timer channels each that operate in Encoder Mode . Further details on the interfacing with timers are given in the Timer section , while information on their decoding is available in the Encoders section . Device Protocol Wheel Encoders ( LM13ICD40AB10F00 ) RS422 Steer Encoder ( RM44SC0012B10F2F10 ) RS422 Timers List of STM timers employed: Timer Mode Pins Description TIM2 Combined Channels: Encoder Mode PA15 (CH1), PB3 (CH2) Left wheel encoder TIM5 Combined Channels: Encoder Mode PA0 (CH1), PA1 (CH2) Right wheel encoder TIM10 Channel1: PWM Generation CH1 PB8 Buzzer PWM output Buzzer As required by the rulebook, the ECU must beep a buzzer for at least (?) ... The buzzer is driven by a MOSFET operated via the PWM output generated by the TIM10 timer on pin PB8, and powered by the 12V line. CAN Fenice's internal networks operate on two CAN buses. Networks Network Interface CAN_TX Pin CAN_RX Pin Primary CAN1 PD1 PD0 Secondary CAN3 PB4 PA8 Bit Timing Parameters APB1 Peripheral Clock (PCLK1): 54 MHz Prescaler: 3 Time Quantum is therefore 55.555 ns Time Quanta in Bit Segment 1: 12 Time Quanta in Bit Segment 2: 5 Time for one bit is therefore 999.99 ns Baud rate is therefore 1000000 bps ( 1 Mbit/s ) ReSynchronization Jump Width: 1 Messages For the list and definition of all CAN messages please refer to the can-cicd documentation . SPI The SPI interface is used to communicate with the Traction Control Unit and exchange information on vehicle state and motor torque. Since the TCU runs on a Raspberry Pi which is, by design, only capable of operating as a Master node, the ECU acts as the Slave node. Interface CLK Pin ... ... For more information on how and what information is exchanged, please refer to the Traction Control section below. IMU This module records the acceleration data coming from the Inertial Measurement Unit (IMU) sensor over the CAN network. Namely, it receives: - Linear acceleration on the three directions - Gyroscopic acceleration on the three axes Sensor Configuration In order to work properly, the sensor needs to be configured with the following parameters: - Sampling frequency: ? - ... IRTS Four Infra-Red Temperature Sensors (IRTSs) are pointed toward the tires and measure their temperature gradient using 8 (?) channels each (...) Inverters The Inverters and the ECU communicate over the CAN network and exchange the following information: - The ECU periodically (at which freq. ?) sends two torque values to be applied to the motors, one for the left side and one for the right side - The inverters periodically (every 100ms) report the contents of their status register (more details below) - The inverters periodically (every 100ms) report the output voltage at which they are driving the motors Status Register Contents Bit Symbol Description 0 Ena Drive Enable 1 RcR0 Speed limit to zero 2 Lim+ Limited switch + tripped 3 Lim- Limited switch - tripped 4 OK Drive okay 5 Icns Current is limited to the continuous current level 6 T-Nlim Speed limit torque mode active 7 P-N Position control active 8 N-I Speed control active 9 <N0 Actual speed is less than 0.1% 10 Rsw Reference switch tripped 11 Cal0 Calibration move active 12 Cal Calibration move completed 13 Tol Position within tolerance window 14 Rdy Drive ready (BTB/RDY contact closed) 15 Brk0 Unexcited brake with motor active 16 SignMag Speed internally inverted 17 Nclip Speed limiting enabled (N-Lim < 90%) 18 Nclip+ Speed limiting (+) via input switch enabled 19 Ncip- Speed limiting (-) via input switch enabled 20 Ird-Dig Current limiting via input switch enabled 21 Iuse-rchd Actual current limit reached 22 Ird-N Current derating to cont. current via speed limit enabled 23 Ird-TI Current derating to cont. current due to igbt temp. enabled 24 Ird-TIR Current derating to cont. current due to igbt temp. active 25 >10Hz Current derating to cont. current at rotation freq. < 10 Hz active 26 Ird-TM Current derating to cont. current due to motor temp. active 27 Ird-Ana Current derating due to analog input (if <= 90%) possible 28 Iwcns Current peak value warning 29 RFEpulse Pulsed RFE - input monitoring active 30 M+d vacant 31 HndWhl Hand-wheel function selected Current-Torque Curve and Power Limiting Note Controlling the inverters by torque or current is equivalent Since, for a given current, power absorption of the motors is proportional to their rotational speed, and given that inverters are controlled in torque/current mode, care must be taken not to request more than the allowed limit of 80 KWh. More details on the matter are available in this report: Essentially, requesting the maximum available current of 200A per motor when the angular velocity is above 4000 RPM causes the power to exceed the allowed limit. To overcome this issue, the following equation must then be followed to obtain the correct torque limit at each rotational speed: \\[ C_{mot\\_max} = \\begin{cases} C_{max} & \\text{if } \\omega_{mot} < \\omega_{limit} \\\\ \\frac{358098.6}{\\omega_{mot}} & \\text{if } \\omega_{mot} \\geq \\omega_{limit} \\end{cases} \\] At this point, the current value must be converted into a 16-bits integer to be sent to the inverters, which is a percent value of the characteristic maximum current of the device, equal to 423A (e.g., 50% = +32768 = 212.5A). Consequently, the maximum current of 200A (corresponding to the 47.3% of the maximum peak) will be represented as 15493. Some clarifying examples follow: Current Percent int16 -423 A -100% -32768 0 A 0% 0 200 A +47.2% +15493 423 A +100% +32768 PCU This module controls all communication (via CAN-Bus) between the ECU and the Pedal Control Unit (PCU). More specifically: - ADC brake and accelerator values are read and scaled from 0 to 100 - Errors and Warnings are checked (e.g. implausibility) - Calibration values are read/written from/to the EEPROM and sent/received Tractive System The TC code handles the generation and delivery of messages concerning the status of the BMS-HV (PRECHARGE, TS-ON, TS-OFF, ...). Traction Control Since the actual software for controlling the traction of the vehicle runs on a separate device (for reliability purposes), the ECU and the Traction Control Unit (TCU) need to constantly exchange a number of values. Parameter Name Direction Description Brake ECU -> TCU How much the brake pedal is pressed ... Further technical details on how this data is exchanged over SPI can be found at the TCU Protocol page. Encoders Magnetic rotative encoders are used to read angular speed from wheels and absolute position from steering. Wheels Wheel encoders are composed of a magnetic ring and a read head. Following, is the data-sheet of the read head where its characteristics are described: Decoding the part number ( LM13ICD40AB10F00 ) and referencing the various tables gives the following key points: Most importantly, we must note that at maximum measurable speed (18.67 m/s, on the ring), each timer will be fed with two 8 MHz signals, leading to 4 million increments/decrements per second. TIM2 and TIM5 have been chosen specifically for their 32-bits counter registers (in contrast with other timers' 16-bits counters) so that they can receive up to 4'294'967'296 pulses before overflowing (instead of 65536 for 16 bits). Consequently, while 16 bit timers would need to be read and reset at most every 16 milliseconds, TIM2 and TIM5 could allow for correct counting for over 17 minutes. Nonetheless, for efficient decoding and to avoid periodic overflows, timer counters should be reset to 0 after every read, which as said, is now free to happen at lower frequencies than every 16 milliseconds, if needed. For information on timer configuration on the STM, see the Timers section . Steering ...","title":"Modules"},{"location":"fenice-ecu/modules/#modules","text":"","title":"Modules"},{"location":"fenice-ecu/modules/#uart","text":"Four devices make use of serial communication: a textual UART for debugging messages, two wheel encoders, and one steering encoder. Among these, however, only the debugging UART is directly interfaced with the STM serial controller: Interface TX Pin RX Pin Baud Rate Description UART4 PA12 PA13 115200 Debugging messages The serial signal from the wheel encoders instead, is decoded by transceivers on the DAS board that, in turn, feed two timer channels each that operate in Encoder Mode . Further details on the interfacing with timers are given in the Timer section , while information on their decoding is available in the Encoders section . Device Protocol Wheel Encoders ( LM13ICD40AB10F00 ) RS422 Steer Encoder ( RM44SC0012B10F2F10 ) RS422","title":"UART"},{"location":"fenice-ecu/modules/#timers","text":"List of STM timers employed: Timer Mode Pins Description TIM2 Combined Channels: Encoder Mode PA15 (CH1), PB3 (CH2) Left wheel encoder TIM5 Combined Channels: Encoder Mode PA0 (CH1), PA1 (CH2) Right wheel encoder TIM10 Channel1: PWM Generation CH1 PB8 Buzzer PWM output","title":"Timers"},{"location":"fenice-ecu/modules/#buzzer","text":"As required by the rulebook, the ECU must beep a buzzer for at least (?) ... The buzzer is driven by a MOSFET operated via the PWM output generated by the TIM10 timer on pin PB8, and powered by the 12V line.","title":"Buzzer"},{"location":"fenice-ecu/modules/#can","text":"Fenice's internal networks operate on two CAN buses.","title":"CAN"},{"location":"fenice-ecu/modules/#networks","text":"Network Interface CAN_TX Pin CAN_RX Pin Primary CAN1 PD1 PD0 Secondary CAN3 PB4 PA8","title":"Networks"},{"location":"fenice-ecu/modules/#bit-timing-parameters","text":"APB1 Peripheral Clock (PCLK1): 54 MHz Prescaler: 3 Time Quantum is therefore 55.555 ns Time Quanta in Bit Segment 1: 12 Time Quanta in Bit Segment 2: 5 Time for one bit is therefore 999.99 ns Baud rate is therefore 1000000 bps ( 1 Mbit/s ) ReSynchronization Jump Width: 1","title":"Bit Timing Parameters"},{"location":"fenice-ecu/modules/#messages","text":"For the list and definition of all CAN messages please refer to the can-cicd documentation .","title":"Messages"},{"location":"fenice-ecu/modules/#spi","text":"The SPI interface is used to communicate with the Traction Control Unit and exchange information on vehicle state and motor torque. Since the TCU runs on a Raspberry Pi which is, by design, only capable of operating as a Master node, the ECU acts as the Slave node. Interface CLK Pin ... ... For more information on how and what information is exchanged, please refer to the Traction Control section below.","title":"SPI"},{"location":"fenice-ecu/modules/#imu","text":"This module records the acceleration data coming from the Inertial Measurement Unit (IMU) sensor over the CAN network. Namely, it receives: - Linear acceleration on the three directions - Gyroscopic acceleration on the three axes","title":"IMU"},{"location":"fenice-ecu/modules/#sensor-configuration","text":"In order to work properly, the sensor needs to be configured with the following parameters: - Sampling frequency: ? - ...","title":"Sensor Configuration"},{"location":"fenice-ecu/modules/#irts","text":"Four Infra-Red Temperature Sensors (IRTSs) are pointed toward the tires and measure their temperature gradient using 8 (?) channels each (...)","title":"IRTS"},{"location":"fenice-ecu/modules/#inverters","text":"The Inverters and the ECU communicate over the CAN network and exchange the following information: - The ECU periodically (at which freq. ?) sends two torque values to be applied to the motors, one for the left side and one for the right side - The inverters periodically (every 100ms) report the contents of their status register (more details below) - The inverters periodically (every 100ms) report the output voltage at which they are driving the motors","title":"Inverters"},{"location":"fenice-ecu/modules/#status-register-contents","text":"Bit Symbol Description 0 Ena Drive Enable 1 RcR0 Speed limit to zero 2 Lim+ Limited switch + tripped 3 Lim- Limited switch - tripped 4 OK Drive okay 5 Icns Current is limited to the continuous current level 6 T-Nlim Speed limit torque mode active 7 P-N Position control active 8 N-I Speed control active 9 <N0 Actual speed is less than 0.1% 10 Rsw Reference switch tripped 11 Cal0 Calibration move active 12 Cal Calibration move completed 13 Tol Position within tolerance window 14 Rdy Drive ready (BTB/RDY contact closed) 15 Brk0 Unexcited brake with motor active 16 SignMag Speed internally inverted 17 Nclip Speed limiting enabled (N-Lim < 90%) 18 Nclip+ Speed limiting (+) via input switch enabled 19 Ncip- Speed limiting (-) via input switch enabled 20 Ird-Dig Current limiting via input switch enabled 21 Iuse-rchd Actual current limit reached 22 Ird-N Current derating to cont. current via speed limit enabled 23 Ird-TI Current derating to cont. current due to igbt temp. enabled 24 Ird-TIR Current derating to cont. current due to igbt temp. active 25 >10Hz Current derating to cont. current at rotation freq. < 10 Hz active 26 Ird-TM Current derating to cont. current due to motor temp. active 27 Ird-Ana Current derating due to analog input (if <= 90%) possible 28 Iwcns Current peak value warning 29 RFEpulse Pulsed RFE - input monitoring active 30 M+d vacant 31 HndWhl Hand-wheel function selected","title":"Status Register Contents"},{"location":"fenice-ecu/modules/#current-torque-curve-and-power-limiting","text":"Note Controlling the inverters by torque or current is equivalent Since, for a given current, power absorption of the motors is proportional to their rotational speed, and given that inverters are controlled in torque/current mode, care must be taken not to request more than the allowed limit of 80 KWh. More details on the matter are available in this report: Essentially, requesting the maximum available current of 200A per motor when the angular velocity is above 4000 RPM causes the power to exceed the allowed limit. To overcome this issue, the following equation must then be followed to obtain the correct torque limit at each rotational speed: \\[ C_{mot\\_max} = \\begin{cases} C_{max} & \\text{if } \\omega_{mot} < \\omega_{limit} \\\\ \\frac{358098.6}{\\omega_{mot}} & \\text{if } \\omega_{mot} \\geq \\omega_{limit} \\end{cases} \\] At this point, the current value must be converted into a 16-bits integer to be sent to the inverters, which is a percent value of the characteristic maximum current of the device, equal to 423A (e.g., 50% = +32768 = 212.5A). Consequently, the maximum current of 200A (corresponding to the 47.3% of the maximum peak) will be represented as 15493. Some clarifying examples follow: Current Percent int16 -423 A -100% -32768 0 A 0% 0 200 A +47.2% +15493 423 A +100% +32768","title":"Current-Torque Curve and Power Limiting"},{"location":"fenice-ecu/modules/#pcu","text":"This module controls all communication (via CAN-Bus) between the ECU and the Pedal Control Unit (PCU). More specifically: - ADC brake and accelerator values are read and scaled from 0 to 100 - Errors and Warnings are checked (e.g. implausibility) - Calibration values are read/written from/to the EEPROM and sent/received","title":"PCU"},{"location":"fenice-ecu/modules/#tractive-system","text":"The TC code handles the generation and delivery of messages concerning the status of the BMS-HV (PRECHARGE, TS-ON, TS-OFF, ...).","title":"Tractive System"},{"location":"fenice-ecu/modules/#traction-control","text":"Since the actual software for controlling the traction of the vehicle runs on a separate device (for reliability purposes), the ECU and the Traction Control Unit (TCU) need to constantly exchange a number of values. Parameter Name Direction Description Brake ECU -> TCU How much the brake pedal is pressed ... Further technical details on how this data is exchanged over SPI can be found at the TCU Protocol page.","title":"Traction Control"},{"location":"fenice-ecu/modules/#encoders","text":"Magnetic rotative encoders are used to read angular speed from wheels and absolute position from steering.","title":"Encoders"},{"location":"fenice-ecu/modules/#wheels","text":"Wheel encoders are composed of a magnetic ring and a read head. Following, is the data-sheet of the read head where its characteristics are described: Decoding the part number ( LM13ICD40AB10F00 ) and referencing the various tables gives the following key points: Most importantly, we must note that at maximum measurable speed (18.67 m/s, on the ring), each timer will be fed with two 8 MHz signals, leading to 4 million increments/decrements per second. TIM2 and TIM5 have been chosen specifically for their 32-bits counter registers (in contrast with other timers' 16-bits counters) so that they can receive up to 4'294'967'296 pulses before overflowing (instead of 65536 for 16 bits). Consequently, while 16 bit timers would need to be read and reset at most every 16 milliseconds, TIM2 and TIM5 could allow for correct counting for over 17 minutes. Nonetheless, for efficient decoding and to avoid periodic overflows, timer counters should be reset to 0 after every read, which as said, is now free to happen at lower frequencies than every 16 milliseconds, if needed. For information on timer configuration on the STM, see the Timers section .","title":"Wheels"},{"location":"fenice-ecu/modules/#steering","text":"...","title":"Steering"},{"location":"fenice-steeringwheel/","text":"Steering Wheel Welcome to the Fenice Steering Wheel documentation. Fenice Steering Wheel is a modular Qt application that interacts with the rest of the vehicle and displays useful information to the team and the pilot during preparation or race. In production the software is deployed to a Raspberry Pi 3b+ into a custom PCB that allows simple communications with all the I/O of the device. During development the software can be tested on any x86 machine that supports Qt natively. Most of the custom I/O is abstracted so complex interaction can still be tested.","title":"Steering Wheel"},{"location":"fenice-steeringwheel/#steering-wheel","text":"Welcome to the Fenice Steering Wheel documentation. Fenice Steering Wheel is a modular Qt application that interacts with the rest of the vehicle and displays useful information to the team and the pilot during preparation or race. In production the software is deployed to a Raspberry Pi 3b+ into a custom PCB that allows simple communications with all the I/O of the device. During development the software can be tested on any x86 machine that supports Qt natively. Most of the custom I/O is abstracted so complex interaction can still be tested.","title":"Steering Wheel"},{"location":"fenice-steeringwheel/development/qt/","text":"Building Qt for the Raspberry Pi This guide is an edited version of the original by abhiTronix . Prerequites A. Hardware Host: Any x86 / x86_64 AMD / Intel machine Target: Raspberry Pi any variant / module B. Software Host: Any Linux machine (Ubuntu 20.04 Tested) Target: Any Raspberry Pi Linux 32-bit OS (Raspbian Buster Tested) C. Others Storage and Time Requirements: The build directory takes around \\~10GB space and about 2-5 hours to complete (based on dependencies & Host Machine Specifications) . Networking: Your Target Machine (Raspberry Pi) and Host Machine (where you cross-compiling) both must have internet access, and must be on same network to follow these instructions. Setup the Target Machine 1. Start from Scratch (Optional) Important: If you just brought a new Raspberry Pi or wanted to start from scratch just follow along. Otherwise, if you already has your Raspberry Pi setup, running, and Network Ready, then just skip to step 2 . Note: This section assume you have atleast 10GB SDcard for installing Raspbian Buster OS and a Laptop/PC for uploading it. 1.1. Download Softwares & Prepare the SD card Download the latest version of Raspbian (Buster) from here on your laptop/pc. You will be needing an image writer to write the downloaded OS into the SD card (micro SD card in our case) . So download the open-source \u201cwin32 disk imager\u201d from here , OR you can also use Balena Etcher instead. Insert the SD card into the laptop/pc and run the image writer. Once open, browse and select the downloaded Raspbian image file. Select the correct device, that is the drive representing the SD card. Note: If the drive (or device) selected is different from the SD card then the other selected drive will become corrupted. SO BE CAREFUL! Once the write is complete, eject the SD card and insert it into the Raspberry Pi and turn it on. It should start booting up. Please remember that after booting the Pi, there might be situations when the user credentials like the \u201cusername\u201d and password will be asked. Raspberry Pi comes with a default username pi and password raspberry and so use it whenever it is being asked. 1.2 Set up Network Now the you have your Raspberry Pi up and Running, its time to connect it your network with one of following ways: If you have Monitor . If you don\u2019t have Monitor Any other way 2. Set up SSH If you have Monitor: On the Raspberry Pi terminal, type: sudo raspi-config and menu should pop up on your terminal. To enable SSH, go to: Interfacing Options -> SSH -> Yes , and Click OK to enable it. Choose Finish finally and exit. If you don\u2019t have Monitor: After setting up the network, if you don\u2019t have monitor or you operating it remotely. Then, enable SSH by just taking out your SD card, and hook it your computer, and simply create an empty file called ssh in the /boot/parition path inside SD card. Now insert back SD card into the Raspberry Pi. 3. Open Terminal From another Laptop/PC using SSH: To connect to your Pi from a different computer, copy and paste the following command into the terminal window but replace 192.160.1.47 with the IP address of the Raspberry Pi. Use Ctrl + Shift + V to paste in the terminal. ssh pi@192.168.1.47 It will ask for password, and if not changed, it is default ( raspberry ), and so use it whenever it is being asked. Note: It is possible to configure your Raspberry Pi to allow access from another computer without needing to provide a password each time you connect. For more details, see here . On Raspberry Pi directly with a Monitor: Just search \u201cTerminal\u201d and click on it. 4. Enable GL (FAKE KMS) To enable Fake KMS, type sudo raspi-config on your terminal to open a menu, then go to: Advanced Options -> A8 GL Driver -> G2 GL (Fake KMS) That should enable KMS. Choose Finish finally and exit. Note: If you are using a minimal build, you may be prompted to download some updates before this option becomes available. If asked, do so. 5. Enable Development Sources You need to edit your sources list to enable development sources. To do this, enter the following command into pi terminal: sudo nano /etc/apt/sources.list In the nano text editor, uncomment the following line by removing the # character from following line: deb-src http://raspbian.raspberrypi.org/raspbian/ buster main contrib non-free rpi When done, press Ctrl+O and then ENTER to quit. 6. Update the system Run the following commands in terminal to update the system sudo apt update sudo apt dist-upgrade 7. Enable rsync with elevated rights Later in this guide, we will be using the rsync command to sync files between the Host PC/Laptop and the Raspberry Pi. For some of these files, root rights (i.e. sudo) is required internally. You can do this with a single terminal command as follows: echo \" $USER ALL=NOPASSWD: $( which rsync ) \" | sudo tee --append /etc/sudoers That\u2019s it. Now rsync should be setup to run with sudo if needed. 8. Install the important Development Packages Run the following commands in Raspberry Pi terminal to install the required packages: sudo apt install build-essential cmake unzip pkg-config gfortran sudo apt build-dep qt5-qmake libqt5gui5 libqt5webengine-data libqt5webkit5 libudev-dev libinput-dev libts-dev libxcb-xinerama0-dev libxcb-xinerama0 gdbserver sudo apt install libxcb-randr0-dev libxcb-xtest0-dev libxcb-shape0-dev libxcb-xkb-dev 9. Additional packages (Optional) You can install these packages if you want additional multimedia and bluetooth capability with your QT binaries: # additional (multimedia) packages sudo apt install libjpeg-dev libpng-dev libtiff-dev sudo apt install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev sudo apt install libxvidcore-dev libx264-dev # audio packages sudo apt install libopenal-data libsndio7.0 libopenal1 libopenal-dev pulseaudio # bluetooth packages sudo apt install bluez-tools sudo apt install libbluetooth-dev # gstreamer (multimedia) packages sudo apt install libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc gstreamer1.0-tools gstreamer1.0-x gstreamer1.0-alsa gstreamer1.0-gl gstreamer1.0-gtk3 gstreamer1.0-qt5 gstreamer1.0-pulseaudio sudo apt install libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev 10. Create directory for QT Deployment Now we create directories where the built QT Binaries will be deployed to your the Rasberry Pi, with following commands: sudo mkdir /usr/local/qt5.15 sudo chown -R pi:pi /usr/local/qt5.15 Also don\u2019t forget to setup Important Symlinks as follows: (Important) sudo ln -sf -r /usr/include/arm-linux-gnueabihf/asm /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/gnu /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/bits /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/sys /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/openssl /usr/include sudo ln -sf /usr/lib/arm-linux-gnueabihf/crtn.o /usr/lib/crtn.o sudo ln -sf /usr/lib/arm-linux-gnueabihf/crt1.o /usr/lib/crt1.o sudo ln -sf /usr/lib/arm-linux-gnueabihf/crti.o /usr/lib/crti.o That\u2019s it for Raspberry Pi setup. Setup the Host Machine Now Raspberry Pi Side all setup, Let\u2019s focus on commands for our Host Machine, i.e. PC/Laptop, where you going to cross-compile the QT Binaries for your Raspberry Pi. Important: Make sure your Raspberry Pi and this Host machine (where you cross-compiling) MUST be on the SAME Network. 1. Update the Host Machine First of all, Run the following commands to update your system and install important dependancies: sudo apt update sudo apt dist-upgrade sudo apt install build-essential cmake unzip gfortran sudo apt install gcc git bison python gperf pkg-config gdb-multiarch wget sudo apt-get -y install gcc g++ gperf flex texinfo gawk bison openssl pigz libncurses-dev autoconf automake tar figlet 2. Setting up the directory structure You can use these following commands to create \u201crpi-qt\u201d to use as workspace for building QT Binaries: sudo mkdir ~/rpi-qt sudo mkdir ~/rpi-qt/build sudo mkdir ~/rpi-qt/tools sudo mkdir ~/rpi-qt/sysroot sudo mkdir ~/rpi-qt/sysroot/usr sudo mkdir ~/rpi-qt/sysroot/opt sudo chown -R 1000 :1000 ~/rpi-qt cd ~/rpi-qt Note: Ensure the last command should have changed your current directory to ~/rpi-qt . If not, run the last line again to make sure you are inside it, as the next steps assume you\u2019re running your commands from this directory. 3. Download & Extract QT Source A. Download Binary Now, we can download the Latest source files for QT LTS (i.e. v5.15.2 ) by running following Terminal command to download the source files: sudo wget http://download.qt.io/archive/qt/5.15/5.15.2/single/qt-everywhere-src-5.15.2.tar.xz Note: You can also manually download file through browser, and place it in the ~/rpi-qt directory. B. Extract Binary Extract the downloaded tar file with the following command: sudo tar xfv qt-everywhere-src-5.15.2.tar.xz 4. Patching QT Source We need to slightly modify the a mkspec file within the source files to allow us to use our cross compiler. We will copy an existing directory within the source files, and modify the name of the directory and the contents of the qmake.conf file within that directory to follow the name of our compiler. To do this, run the following two command: cp -R qt-everywhere-src-5.15.2/qtbase/mkspecs/linux-arm-gnueabi-g++ qt-everywhere-src-5.15.2/qtbase/mkspecs/linux-arm-gnueabihf-g++ sed -i -e 's/arm-linux-gnueabi-/arm-linux-gnueabihf-/g' qt-everywhere-src-5.15.2/qtbase/mkspecs/linux-arm-gnueabihf-g++/qmake.conf 5. Download & Extract the Precompiled Cross-Compiler Let\u2019s first change into tools directory for downloading our Precompiled Cross-compiler with the following command: cd ~/rpi-qt/tools Note: Ensure the last command should have changed your current directory to ~/rpi-qt/tools now. If not, run it again. A. Copy Binary URL Copy URL from one of following Precompiled Compressed Base-Toolchain (for maximum compatability) based on your Raspberry Pi Variant and OS you installed on it, from below: Raspberry Pi Board Stretch (32 bit) Buster (32 bit) Zero/W/WH & 1 Model A/B/A+/B+ https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Stretch/GCC%206.3.0/Raspberry%20Pi%201%2C%20Zero/cross-gcc-6.3.0-pi_0-1.tar.gz https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%201%2C%20Zero/cross-gcc-8.3.0-pi_0-1.tar.gz 2 & 3 Model A/B https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Stretch/GCC%206.3.0/Raspberry%20Pi%202%2C%203/cross-gcc-6.3.0-pi_2-3.tar.gz https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%202%2C%203/cross-gcc-8.3.0-pi_2-3.tar.gz 3 & 4 Model A+/B+ & Compute 3/3-lite/3+ https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Stretch/GCC%206.3.0/Raspberry%20Pi%203A%2B%2C%203B%2B%2C%204/cross-gcc-6.3.0-pi_3%2B.tar.gz https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%203A%2B%2C%203B%2B%2C%204/cross-gcc-8.3.0-pi_3%2B.tar.gz Note: You can also use the latest cross-compiler binaries instead. But they are not tested. B. Download Binary After that, paste your copied URL and run the following command to download the Cross-compiler: wget <Copied Binary URL goes here> #for e.g. => wget https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%202%2C%203/cross-gcc-8.3.0-pi_2-3.tar.gz C. Extract Binary Once it is downloaded, we can extract it using the following command: tar xf cross-gcc-*.tar.gz 6. Sync Raspberry Pi sysroot (Most Important) First, let\u2019s move back into the rpi folder as needed for the next sections: cd ~/rpi-qt Now, we need to sync up our sysroot folder with the system files from the Raspberry Pi. We will be using rsync that let us sync (i.e. copy) files from the Raspberry Pi with appropriate permission onto your Host Machine, potentially saving you alot of time. To do this, enter the following commands one by one into your terminal (change ``192.168.1.47`` with the IP address of your Raspberry Pi present on the same network) : Command 1: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/lib sysroot Command 2: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/usr/include sysroot/usr Command 3: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/usr/lib sysroot/usr Command 4: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/opt/vc sysroot/opt Note: Double check after each of the above commands that all the files have been copied to ~/rpi-qt/sysroot folder. There will be an information message if there were any issues. 7. Fix symbolic links The files we copied in the previous step still have symbolic links pointing to the file system on the Raspberry Pi. We need to alter this so that they become relative links from the new sysroot directory on the host machine. We can do this with a python script, which we can download as follows: wget https://raw.githubusercontent.com/abhiTronix/rpi_rootfs/master/scripts/sysroot-relativelinks.py Once it is downloaded, you just need to make it executable and run it, using the following commands: sudo chmod +x sysroot-relativelinks.py ./sysroot-relativelinks.py sysroot 8. Configure QT Build Let\u2019s move into the build directory for further steps, as we don\u2019t want to build within that source directory as its crowded, so we will access it from within this this directory: cd ~/rpi-qt/build Finally, Now we can configure our QT build. We need to run the configure script inside QT source to configure our build. Run following command to configure the build, including all the necessary options: CROSS_COMPILER_LOCATION = $HOME /rpi-qt/tools/cross-pi-gcc-* ../qt-everywhere-src-5.15.2/configure -release -opengl es2 -eglfs -device linux-rasp-pi4-v3d-g++ -device-option CROSS_COMPILE = $( echo $CROSS_COMPILER_LOCATION ) /bin/arm-linux-gnueabihf- -sysroot ~/rpi-qt/sysroot/ -prefix /usr/local/qt5.15 -extprefix ~/rpi-qt/qt5.15 -opensource -confirm-license -skip qtscript -skip qtwayland -skip qtwebengine -nomake tests -make libs -pkg-config -no-use-gold-linker -v -recheck -L $HOME /rpi-qt/sysroot/usr/lib/arm-linux-gnueabihf -I $HOME /rpi-qt/sysroot/usr/include/arm-linux-gnueabihf The configure script may take a few minutes to complete. 8.1 Check Configure Output Once it is completed you should get a summary of what has been configured. Make sure the following options appear: Configure summary: Building on: linux-g++ ( x86_64, CPU features: mmx sse sse2 ) Building for : devices/linux-rasp-pi4-v3d-g++ ( arm, CPU features: neon ) Target compiler: gcc 8 .3.0 Configuration: cross_compile compile_examples enable_new_dtags largefile neon precompile_header shared shared rpath release c++11 c++14 c++17 c++1z concurrent dbus reduce_exports stl 8.2 Check if EGLFS enabled QPA backends: EGLFS .................................. yes [ SHOULD BE YES ] EGLFS details: EGLFS OpenWFD ........................ no EGLFS i.Mx6 .......................... no EGLFS i.Mx6 Wayland .................. no EGLFS RCAR ........................... no EGLFS EGLDevice ...................... yes [ SHOULD BE YES ] EGLFS GBM ............................ yes EGLFS VSP2 ........................... no EGLFS Mali ........................... no EGLFS Raspberry Pi ................... no [ SHOULD BE NO ] EGLFS X11 ............................ yes If the your configuration summary doesn\u2019t have the EGLFS features set to what\u2019s shown above, something has probably gone wrong. You can look at the config.log file in the build directory to try and diagnose what the issue might be. If all looks good and all libraries you need have been installed we can continue to the next section 9. Build QT Source Our build has been configured now, and it is time to actually build the source files, and run the following command: Important: Ensure you are still in the ~/rpi-qt/build directory make -j $( nproc ) Note: -j$(nproc) option indicates that the job should be spread into mutliple threads and run in parallel on available cores. \u2615\ufe0f This process will take some time! 10. Install QT Source Once it is completed, we can install the built package using the following command: make install This should install the files in the correct directories 11. Deploy QT to Raspberry Pi First move back into the rpi folder using the following command: cd ~/rpi-qt Now, We can now deploy built QT Binaries (contained in ``qt5.15`` folder in ``~/rpi-qt`` directory) back to our Raspberry Pi, again using rsync command. Just run the following command (change ``192.168.1.47`` with the IP address of your Raspberry Pi present on the same network) : rsync -avz --rsync-path = \"sudo rsync\" qt5.15 pi@192.168.1.47:/usr/local Final Step for Target Machine Update linker on Raspberry Pi Enter the following command to update the device letting the linker to find the new QT binary files: echo /usr/local/qt5.15/lib | sudo tee /etc/ld.so.conf.d/qt5.15.conf sudo ldconfig For Raspberry Pi 2: If you\u2019re facing issues with running the example, try to use 00-qt5pi.conf instead of qt5pi.conf , in the above command. \ud83c\udf7b That should be it! You have now succesfully installed latest QT 5.15.2 on the Raspberry Pi.","title":"Building Qt for the Raspberry Pi"},{"location":"fenice-steeringwheel/development/qt/#building-qt-for-the-raspberry-pi","text":"This guide is an edited version of the original by abhiTronix .","title":"Building Qt for the Raspberry Pi"},{"location":"fenice-steeringwheel/development/qt/#prerequites","text":"","title":"Prerequites"},{"location":"fenice-steeringwheel/development/qt/#a-hardware","text":"Host: Any x86 / x86_64 AMD / Intel machine Target: Raspberry Pi any variant / module","title":"A. Hardware"},{"location":"fenice-steeringwheel/development/qt/#b-software","text":"Host: Any Linux machine (Ubuntu 20.04 Tested) Target: Any Raspberry Pi Linux 32-bit OS (Raspbian Buster Tested)","title":"B. Software"},{"location":"fenice-steeringwheel/development/qt/#c-others","text":"Storage and Time Requirements: The build directory takes around \\~10GB space and about 2-5 hours to complete (based on dependencies & Host Machine Specifications) . Networking: Your Target Machine (Raspberry Pi) and Host Machine (where you cross-compiling) both must have internet access, and must be on same network to follow these instructions.","title":"C. Others"},{"location":"fenice-steeringwheel/development/qt/#setup-the-target-machine","text":"","title":"Setup the Target Machine"},{"location":"fenice-steeringwheel/development/qt/#1-start-from-scratch-optional","text":"Important: If you just brought a new Raspberry Pi or wanted to start from scratch just follow along. Otherwise, if you already has your Raspberry Pi setup, running, and Network Ready, then just skip to step 2 . Note: This section assume you have atleast 10GB SDcard for installing Raspbian Buster OS and a Laptop/PC for uploading it.","title":"1. Start from Scratch (Optional)"},{"location":"fenice-steeringwheel/development/qt/#11-download-softwares-prepare-the-sd-card","text":"Download the latest version of Raspbian (Buster) from here on your laptop/pc. You will be needing an image writer to write the downloaded OS into the SD card (micro SD card in our case) . So download the open-source \u201cwin32 disk imager\u201d from here , OR you can also use Balena Etcher instead. Insert the SD card into the laptop/pc and run the image writer. Once open, browse and select the downloaded Raspbian image file. Select the correct device, that is the drive representing the SD card. Note: If the drive (or device) selected is different from the SD card then the other selected drive will become corrupted. SO BE CAREFUL! Once the write is complete, eject the SD card and insert it into the Raspberry Pi and turn it on. It should start booting up. Please remember that after booting the Pi, there might be situations when the user credentials like the \u201cusername\u201d and password will be asked. Raspberry Pi comes with a default username pi and password raspberry and so use it whenever it is being asked.","title":"1.1. Download Softwares &amp; Prepare the SD card"},{"location":"fenice-steeringwheel/development/qt/#12-set-up-network","text":"Now the you have your Raspberry Pi up and Running, its time to connect it your network with one of following ways: If you have Monitor . If you don\u2019t have Monitor Any other way","title":"1.2 Set up Network"},{"location":"fenice-steeringwheel/development/qt/#2-set-up-ssh","text":"If you have Monitor: On the Raspberry Pi terminal, type: sudo raspi-config and menu should pop up on your terminal. To enable SSH, go to: Interfacing Options -> SSH -> Yes , and Click OK to enable it. Choose Finish finally and exit. If you don\u2019t have Monitor: After setting up the network, if you don\u2019t have monitor or you operating it remotely. Then, enable SSH by just taking out your SD card, and hook it your computer, and simply create an empty file called ssh in the /boot/parition path inside SD card. Now insert back SD card into the Raspberry Pi.","title":"2. Set up SSH"},{"location":"fenice-steeringwheel/development/qt/#3-open-terminal","text":"From another Laptop/PC using SSH: To connect to your Pi from a different computer, copy and paste the following command into the terminal window but replace 192.160.1.47 with the IP address of the Raspberry Pi. Use Ctrl + Shift + V to paste in the terminal. ssh pi@192.168.1.47 It will ask for password, and if not changed, it is default ( raspberry ), and so use it whenever it is being asked. Note: It is possible to configure your Raspberry Pi to allow access from another computer without needing to provide a password each time you connect. For more details, see here . On Raspberry Pi directly with a Monitor: Just search \u201cTerminal\u201d and click on it.","title":"3. Open Terminal"},{"location":"fenice-steeringwheel/development/qt/#4-enable-gl-fake-kms","text":"To enable Fake KMS, type sudo raspi-config on your terminal to open a menu, then go to: Advanced Options -> A8 GL Driver -> G2 GL (Fake KMS) That should enable KMS. Choose Finish finally and exit. Note: If you are using a minimal build, you may be prompted to download some updates before this option becomes available. If asked, do so.","title":"4. Enable GL (FAKE KMS)"},{"location":"fenice-steeringwheel/development/qt/#5-enable-development-sources","text":"You need to edit your sources list to enable development sources. To do this, enter the following command into pi terminal: sudo nano /etc/apt/sources.list In the nano text editor, uncomment the following line by removing the # character from following line: deb-src http://raspbian.raspberrypi.org/raspbian/ buster main contrib non-free rpi When done, press Ctrl+O and then ENTER to quit.","title":"5. Enable Development Sources"},{"location":"fenice-steeringwheel/development/qt/#6-update-the-system","text":"Run the following commands in terminal to update the system sudo apt update sudo apt dist-upgrade","title":"6. Update the system"},{"location":"fenice-steeringwheel/development/qt/#7-enable-rsync-with-elevated-rights","text":"Later in this guide, we will be using the rsync command to sync files between the Host PC/Laptop and the Raspberry Pi. For some of these files, root rights (i.e. sudo) is required internally. You can do this with a single terminal command as follows: echo \" $USER ALL=NOPASSWD: $( which rsync ) \" | sudo tee --append /etc/sudoers That\u2019s it. Now rsync should be setup to run with sudo if needed.","title":"7. Enable rsync with elevated rights"},{"location":"fenice-steeringwheel/development/qt/#8-install-the-important-development-packages","text":"Run the following commands in Raspberry Pi terminal to install the required packages: sudo apt install build-essential cmake unzip pkg-config gfortran sudo apt build-dep qt5-qmake libqt5gui5 libqt5webengine-data libqt5webkit5 libudev-dev libinput-dev libts-dev libxcb-xinerama0-dev libxcb-xinerama0 gdbserver sudo apt install libxcb-randr0-dev libxcb-xtest0-dev libxcb-shape0-dev libxcb-xkb-dev","title":"8. Install the important Development Packages"},{"location":"fenice-steeringwheel/development/qt/#9-additional-packages-optional","text":"You can install these packages if you want additional multimedia and bluetooth capability with your QT binaries: # additional (multimedia) packages sudo apt install libjpeg-dev libpng-dev libtiff-dev sudo apt install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev sudo apt install libxvidcore-dev libx264-dev # audio packages sudo apt install libopenal-data libsndio7.0 libopenal1 libopenal-dev pulseaudio # bluetooth packages sudo apt install bluez-tools sudo apt install libbluetooth-dev # gstreamer (multimedia) packages sudo apt install libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc gstreamer1.0-tools gstreamer1.0-x gstreamer1.0-alsa gstreamer1.0-gl gstreamer1.0-gtk3 gstreamer1.0-qt5 gstreamer1.0-pulseaudio sudo apt install libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev","title":"9. Additional packages (Optional)"},{"location":"fenice-steeringwheel/development/qt/#10-create-directory-for-qt-deployment","text":"Now we create directories where the built QT Binaries will be deployed to your the Rasberry Pi, with following commands: sudo mkdir /usr/local/qt5.15 sudo chown -R pi:pi /usr/local/qt5.15 Also don\u2019t forget to setup Important Symlinks as follows: (Important) sudo ln -sf -r /usr/include/arm-linux-gnueabihf/asm /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/gnu /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/bits /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/sys /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/openssl /usr/include sudo ln -sf /usr/lib/arm-linux-gnueabihf/crtn.o /usr/lib/crtn.o sudo ln -sf /usr/lib/arm-linux-gnueabihf/crt1.o /usr/lib/crt1.o sudo ln -sf /usr/lib/arm-linux-gnueabihf/crti.o /usr/lib/crti.o That\u2019s it for Raspberry Pi setup.","title":"10. Create directory for QT Deployment"},{"location":"fenice-steeringwheel/development/qt/#setup-the-host-machine","text":"Now Raspberry Pi Side all setup, Let\u2019s focus on commands for our Host Machine, i.e. PC/Laptop, where you going to cross-compile the QT Binaries for your Raspberry Pi. Important: Make sure your Raspberry Pi and this Host machine (where you cross-compiling) MUST be on the SAME Network.","title":"Setup the Host Machine"},{"location":"fenice-steeringwheel/development/qt/#1-update-the-host-machine","text":"First of all, Run the following commands to update your system and install important dependancies: sudo apt update sudo apt dist-upgrade sudo apt install build-essential cmake unzip gfortran sudo apt install gcc git bison python gperf pkg-config gdb-multiarch wget sudo apt-get -y install gcc g++ gperf flex texinfo gawk bison openssl pigz libncurses-dev autoconf automake tar figlet","title":"1. Update the Host Machine"},{"location":"fenice-steeringwheel/development/qt/#2-setting-up-the-directory-structure","text":"You can use these following commands to create \u201crpi-qt\u201d to use as workspace for building QT Binaries: sudo mkdir ~/rpi-qt sudo mkdir ~/rpi-qt/build sudo mkdir ~/rpi-qt/tools sudo mkdir ~/rpi-qt/sysroot sudo mkdir ~/rpi-qt/sysroot/usr sudo mkdir ~/rpi-qt/sysroot/opt sudo chown -R 1000 :1000 ~/rpi-qt cd ~/rpi-qt Note: Ensure the last command should have changed your current directory to ~/rpi-qt . If not, run the last line again to make sure you are inside it, as the next steps assume you\u2019re running your commands from this directory.","title":"2. Setting up the directory structure"},{"location":"fenice-steeringwheel/development/qt/#3-download-extract-qt-source","text":"","title":"3. Download &amp; Extract QT Source"},{"location":"fenice-steeringwheel/development/qt/#a-download-binary","text":"Now, we can download the Latest source files for QT LTS (i.e. v5.15.2 ) by running following Terminal command to download the source files: sudo wget http://download.qt.io/archive/qt/5.15/5.15.2/single/qt-everywhere-src-5.15.2.tar.xz Note: You can also manually download file through browser, and place it in the ~/rpi-qt directory.","title":"A. Download Binary"},{"location":"fenice-steeringwheel/development/qt/#b-extract-binary","text":"Extract the downloaded tar file with the following command: sudo tar xfv qt-everywhere-src-5.15.2.tar.xz","title":"B. Extract Binary"},{"location":"fenice-steeringwheel/development/qt/#4-patching-qt-source","text":"We need to slightly modify the a mkspec file within the source files to allow us to use our cross compiler. We will copy an existing directory within the source files, and modify the name of the directory and the contents of the qmake.conf file within that directory to follow the name of our compiler. To do this, run the following two command: cp -R qt-everywhere-src-5.15.2/qtbase/mkspecs/linux-arm-gnueabi-g++ qt-everywhere-src-5.15.2/qtbase/mkspecs/linux-arm-gnueabihf-g++ sed -i -e 's/arm-linux-gnueabi-/arm-linux-gnueabihf-/g' qt-everywhere-src-5.15.2/qtbase/mkspecs/linux-arm-gnueabihf-g++/qmake.conf","title":"4. Patching QT Source"},{"location":"fenice-steeringwheel/development/qt/#5-download-extract-the-precompiled-cross-compiler","text":"Let\u2019s first change into tools directory for downloading our Precompiled Cross-compiler with the following command: cd ~/rpi-qt/tools Note: Ensure the last command should have changed your current directory to ~/rpi-qt/tools now. If not, run it again.","title":"5. Download &amp; Extract the Precompiled Cross-Compiler"},{"location":"fenice-steeringwheel/development/qt/#a-copy-binary-url","text":"Copy URL from one of following Precompiled Compressed Base-Toolchain (for maximum compatability) based on your Raspberry Pi Variant and OS you installed on it, from below: Raspberry Pi Board Stretch (32 bit) Buster (32 bit) Zero/W/WH & 1 Model A/B/A+/B+ https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Stretch/GCC%206.3.0/Raspberry%20Pi%201%2C%20Zero/cross-gcc-6.3.0-pi_0-1.tar.gz https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%201%2C%20Zero/cross-gcc-8.3.0-pi_0-1.tar.gz 2 & 3 Model A/B https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Stretch/GCC%206.3.0/Raspberry%20Pi%202%2C%203/cross-gcc-6.3.0-pi_2-3.tar.gz https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%202%2C%203/cross-gcc-8.3.0-pi_2-3.tar.gz 3 & 4 Model A+/B+ & Compute 3/3-lite/3+ https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Stretch/GCC%206.3.0/Raspberry%20Pi%203A%2B%2C%203B%2B%2C%204/cross-gcc-6.3.0-pi_3%2B.tar.gz https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%203A%2B%2C%203B%2B%2C%204/cross-gcc-8.3.0-pi_3%2B.tar.gz Note: You can also use the latest cross-compiler binaries instead. But they are not tested.","title":"A. Copy Binary URL"},{"location":"fenice-steeringwheel/development/qt/#b-download-binary","text":"After that, paste your copied URL and run the following command to download the Cross-compiler: wget <Copied Binary URL goes here> #for e.g. => wget https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%202%2C%203/cross-gcc-8.3.0-pi_2-3.tar.gz","title":"B. Download Binary"},{"location":"fenice-steeringwheel/development/qt/#c-extract-binary","text":"Once it is downloaded, we can extract it using the following command: tar xf cross-gcc-*.tar.gz","title":"C. Extract Binary"},{"location":"fenice-steeringwheel/development/qt/#6-sync-raspberry-pi-sysroot-most-important","text":"First, let\u2019s move back into the rpi folder as needed for the next sections: cd ~/rpi-qt Now, we need to sync up our sysroot folder with the system files from the Raspberry Pi. We will be using rsync that let us sync (i.e. copy) files from the Raspberry Pi with appropriate permission onto your Host Machine, potentially saving you alot of time. To do this, enter the following commands one by one into your terminal (change ``192.168.1.47`` with the IP address of your Raspberry Pi present on the same network) : Command 1: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/lib sysroot Command 2: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/usr/include sysroot/usr Command 3: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/usr/lib sysroot/usr Command 4: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/opt/vc sysroot/opt Note: Double check after each of the above commands that all the files have been copied to ~/rpi-qt/sysroot folder. There will be an information message if there were any issues.","title":"6. Sync Raspberry Pi sysroot (Most Important)"},{"location":"fenice-steeringwheel/development/qt/#7-fix-symbolic-links","text":"The files we copied in the previous step still have symbolic links pointing to the file system on the Raspberry Pi. We need to alter this so that they become relative links from the new sysroot directory on the host machine. We can do this with a python script, which we can download as follows: wget https://raw.githubusercontent.com/abhiTronix/rpi_rootfs/master/scripts/sysroot-relativelinks.py Once it is downloaded, you just need to make it executable and run it, using the following commands: sudo chmod +x sysroot-relativelinks.py ./sysroot-relativelinks.py sysroot","title":"7. Fix symbolic links"},{"location":"fenice-steeringwheel/development/qt/#8-configure-qt-build","text":"Let\u2019s move into the build directory for further steps, as we don\u2019t want to build within that source directory as its crowded, so we will access it from within this this directory: cd ~/rpi-qt/build Finally, Now we can configure our QT build. We need to run the configure script inside QT source to configure our build. Run following command to configure the build, including all the necessary options: CROSS_COMPILER_LOCATION = $HOME /rpi-qt/tools/cross-pi-gcc-* ../qt-everywhere-src-5.15.2/configure -release -opengl es2 -eglfs -device linux-rasp-pi4-v3d-g++ -device-option CROSS_COMPILE = $( echo $CROSS_COMPILER_LOCATION ) /bin/arm-linux-gnueabihf- -sysroot ~/rpi-qt/sysroot/ -prefix /usr/local/qt5.15 -extprefix ~/rpi-qt/qt5.15 -opensource -confirm-license -skip qtscript -skip qtwayland -skip qtwebengine -nomake tests -make libs -pkg-config -no-use-gold-linker -v -recheck -L $HOME /rpi-qt/sysroot/usr/lib/arm-linux-gnueabihf -I $HOME /rpi-qt/sysroot/usr/include/arm-linux-gnueabihf The configure script may take a few minutes to complete.","title":"8. Configure QT Build"},{"location":"fenice-steeringwheel/development/qt/#81-check-configure-output","text":"Once it is completed you should get a summary of what has been configured. Make sure the following options appear: Configure summary: Building on: linux-g++ ( x86_64, CPU features: mmx sse sse2 ) Building for : devices/linux-rasp-pi4-v3d-g++ ( arm, CPU features: neon ) Target compiler: gcc 8 .3.0 Configuration: cross_compile compile_examples enable_new_dtags largefile neon precompile_header shared shared rpath release c++11 c++14 c++17 c++1z concurrent dbus reduce_exports stl","title":"8.1 Check Configure Output"},{"location":"fenice-steeringwheel/development/qt/#82-check-if-eglfs-enabled","text":"QPA backends: EGLFS .................................. yes [ SHOULD BE YES ] EGLFS details: EGLFS OpenWFD ........................ no EGLFS i.Mx6 .......................... no EGLFS i.Mx6 Wayland .................. no EGLFS RCAR ........................... no EGLFS EGLDevice ...................... yes [ SHOULD BE YES ] EGLFS GBM ............................ yes EGLFS VSP2 ........................... no EGLFS Mali ........................... no EGLFS Raspberry Pi ................... no [ SHOULD BE NO ] EGLFS X11 ............................ yes If the your configuration summary doesn\u2019t have the EGLFS features set to what\u2019s shown above, something has probably gone wrong. You can look at the config.log file in the build directory to try and diagnose what the issue might be. If all looks good and all libraries you need have been installed we can continue to the next section","title":"8.2 Check if EGLFS enabled"},{"location":"fenice-steeringwheel/development/qt/#9-build-qt-source","text":"Our build has been configured now, and it is time to actually build the source files, and run the following command: Important: Ensure you are still in the ~/rpi-qt/build directory make -j $( nproc ) Note: -j$(nproc) option indicates that the job should be spread into mutliple threads and run in parallel on available cores. \u2615\ufe0f This process will take some time!","title":"9. Build QT Source"},{"location":"fenice-steeringwheel/development/qt/#10-install-qt-source","text":"Once it is completed, we can install the built package using the following command: make install This should install the files in the correct directories","title":"10. Install QT Source"},{"location":"fenice-steeringwheel/development/qt/#11-deploy-qt-to-raspberry-pi","text":"First move back into the rpi folder using the following command: cd ~/rpi-qt Now, We can now deploy built QT Binaries (contained in ``qt5.15`` folder in ``~/rpi-qt`` directory) back to our Raspberry Pi, again using rsync command. Just run the following command (change ``192.168.1.47`` with the IP address of your Raspberry Pi present on the same network) : rsync -avz --rsync-path = \"sudo rsync\" qt5.15 pi@192.168.1.47:/usr/local","title":"11. Deploy QT to Raspberry Pi"},{"location":"fenice-steeringwheel/development/qt/#final-step-for-target-machine","text":"","title":"Final Step for Target Machine"},{"location":"fenice-steeringwheel/development/qt/#update-linker-on-raspberry-pi","text":"Enter the following command to update the device letting the linker to find the new QT binary files: echo /usr/local/qt5.15/lib | sudo tee /etc/ld.so.conf.d/qt5.15.conf sudo ldconfig For Raspberry Pi 2: If you\u2019re facing issues with running the example, try to use 00-qt5pi.conf instead of qt5pi.conf , in the above command. \ud83c\udf7b That should be it! You have now succesfully installed latest QT 5.15.2 on the Raspberry Pi.","title":"Update linker on Raspberry Pi"},{"location":"fenice-steeringwheel/interface/tabs/","text":"Concept of Tabs","title":"Concept of Tabs"},{"location":"fenice-steeringwheel/interface/tabs/#concept-of-tabs","text":"","title":"Concept of Tabs"},{"location":"handcart-hw/handcart/","text":"Handcart / Charger","title":"Handcart / Charger"},{"location":"handcart-hw/handcart/#handcart-charger","text":"","title":"Handcart / Charger"},{"location":"handcart-sw/main/","text":"Handcart Documentation Index Structure Resources & Useful links Intro The handcart is the device that is responsible of transporting and charging the car's accumulator. It is based on three main components: Brusa NLG513 charger, that is the actual charger Raspberry pi 4 to run the software High Voltage Accumulator The rasp is connected via CAN Bus with the BMS in the accumulator and with the Brusa charger. The software of the handcart is responsible of all the processes to ensure a good and safe charge. Abbreviations BMS, porco, acc -> accumulator HV -> High Voltage rasp -> raspberry FSM -> Finite State Machine TS (on, off) -> Tractive system (HV) (on o off) Software Overview The software is written in python and javascript. It's divided in two parts, respectively frontend and backend. The backend is responsible to manage the charge and to communicate with the devices, and it also hosts a webserver for the frontend. Backend The backend is the part of the software that is responsible to manage the charge and to communicate with the devices, it also hosts a webserver to serve pages and data to the frontend. Basically it is a python script that becomes a process, then it splits itself in three threads. Threads The three threads are: The state machine, aka the main thread The flask webserver The CAN read/write process The three threads have an class istance that they can access which is in shared memory, accessed with a lock. Other types of communication are two queues: A queue for can msg send between FSM thread and CAN thread A queue for can msg recv between FSM thread and CAN thread A queue for command send between web server and the FSM Main thread with FSM The FSM is based on multiple states: CHECK: It is a state where the presence of the BMS and the BRUSA are checked, if they are both present it will pass to next state IDLE: Both devices are connected and ready to rock, a precharge command is waited PRECHARGE: Accumulator is asked TS ON, wait until a confirmation is received READY: Accumulator is in TS ON, brusa is ready, waiting for a charge command CHARGE: The charge is enabled C_DONE: The charge is finished ERROR: An error state, the charge (if enabled) is stopped, the BMS is asked to TS OFF, the PON of brusa is set to OFF Note that in each state there's a check over errors from the can, if an error is found, the next state will be ERROR STATE:CHECK The presence of BMS and BRUSA is checked, if both are present, goto IDLE STATE:IDLE Both devices are connected and ready to rock, a precharge command is waited. STATE:PRECHARGE A TS ON can message is sent to BMS HV, which will do the precharge. In this state we will check if the bms will finish the precharge. Once it did so, the FSM willl go to READY state. STATE:READY The TS is on, we are waiting to receive the charge command from the webserver. We countinously check the queue for new messages. STATE:CHARGE In this state the charge is enabled, to do this, a variable named \"can_forward_enabled\" is set to True. This variable is shared between the FSM trhead and the CAN thread. In the can thread, a check over can_forward_enabled is made, if it's False it will periodically send an empty CAN message to brusa (this is important to keep the link alive, otherwise the brusa will go in an error state if no msgs receivedin 300ms) If it's True, it will send an enable charge command to brusa with the voltage and current settings. For more info check the brusa CAN messages matrix. STATE:C_DONE The charge is done, TS is still on, waiting for user input. STATE:ERROR Something triggered an error, we have to turn off everithing that could be dangerous. The method \"staccastacca()\" is called. Where a TS_OFF message both for chimera's and fenice's accumulator is sent. The message is sent until a confirmation about the fact that the TS is OFF is received. In the staccastacca method also the PON is disabled The canread object The 'canread' object is an istance of a class that is thought to store all the information of the BMS, BRUSA, CAN and others. It is also used to process all the CAN messages. The CAN thread passes the can messages in the CAN queue and the FSM thread checks for new messages in the queue at each cycle, if so the message is processed in the canread object using a method. The canread object is accessed only by the thread of the FSM, the other threads access a copy of that object that is called shared_data. This is done for safety reason and to assure a fast access without lag to the main thread, as this object contains error state variables. Flask HTTP server This is the server that serve the requests received from the frontend. It uses the shared_data object to retrieve the data from the FSM thread Frontend The handcart's frontend is a webapp based on javascript and html, it fetches the data from the backend by doing RESTFUL requests to the backend. Chart are created using amcharts 4 (https://www.amcharts.com/) with Javascript method (NOT the JSON method). To use fetches there are some basic method such as the request-create and the POST method to submit data. I strongly recommend you to use the \"formListener\" method that take a form and the partial URL (because we have to send commands only on the \"/command/\" path, so we can avoid things that can't be done) In forms I create some hidden parameters to identify the command we want to send and it have to correspond with the json parameters shown in the documentation describing the json format. include/header.html Is the top-bar that have all status, number of warnings and errors, and actual value for each parameter needed. The error and warning's counter can be clicked to access the respective pages. Every value in the header are calculated by the js/status.js file, which will be loaded on page loading. There's also a big SHUTDOWN button to turn off the charge every time, independently whether page you are. index.html This page has six charts: the first on top-left graphically describe the latest voltage values, then you have the charge percentage and the latest current values on the first row. On the second row there are the latest temperature's chart and two charts about cells voltage and temperature that will work only with Fenice (Chimera still don't have these values). Data are received by the flask server using a fetch for each chart to fill the previous data (30 zeros to avoid graphical issues) and then another fetch will be called to ask the server the last data, in order to have a live chart (every 2 seconds). error.html and warning.html These two pages just print BMS-HV and Brusa errors and warnings in a table. The creating-table method is inside the js/tables.js file and look at the json's parameters to create the table. If you need to print a json with the \"title-parameter\" in one column instead of on a row, follow the method used in brusa-info.html. brusa-info.html In this page are displayed some Brusa's flags in a table made as described above. settings.html Here you can modify some parameters, for example the Cut-Off voltage, the maximum current outlet and a button to enable or disable the fastcharge. chart.html This page can actually display \"more pages\": it depends on the parameter passed using the GET method. This parameter is used to set a title in the page and to decide which chart you want to display. At this point it will automatically check which chart-function it has to call and calls also the functions to update the header's values. Those charts won't refresh automatically: you have to refresh the page to see all new data, so you can use the zoom (by clicking in the start position and drag until the end position of the zoom). To seeing all values about a specific chart there is a function called \"createMultilineChart\" that will create a chart with many lines as parameters that are in the json (timestamp excluded). Chart functions In addition to chart's creating functions there are some utilities functions in \"/chart/chartsFun.js\": most of them are in this file just to clear the main one and to reuse them if needed, however they contain the more logical part (i.e. how to set the correct color using a percentage or how to set the correct position of each cell value according to the real position - check the image below to understand it better). Raspberry configuration Follow the guide here Rasp config . The password of the raspberry is \"handcartpi\". In the handcart just one CAN bus is necessary. Hardware Electrical wiring Modular cables for Accumulator connection I decided to create two modular cables that have a common connector handcart-side, but different connectors at accumulator-side, in a way that we are able to easily switch the connectors between the two accumulators. Both cables connect to the handcart via an Amphenol AT06-12SX1 connector, having these pin mapping: 1 - 12V Supply 2 - 5V Supply (only chimera) 3 - CAN H 4 - TSMS 5 - RESET 6 - IMD LED 7 - Cockpit LED 8 - BMS LED 9 - TO TSMS 10 - CAN L 11 - SD 12 - GND Chimera Evoluzione accumulator cable To the other side of the cable we have two connectors, LV-CAN and SD IMD BMS. They use the same connectors used for chimera\u2019s CAN. LV-CAN pin mapping: 1 - RESET 2 - BMS LED 3 - empty 4 - TO TSMS 5 - SD 6 - empty 7 - IMD 8 - TSMS SD IMD BMS pin mapping: As chimera can connectors standard Fenice accumulator cable As for chimera it has two connectors to the other end of the cable, this time, the connectors are TE 776273-1 for SD IMD BMS and CeeLok FAS-T for LV CAN. Tip Tip for the CeeLok FAS-T connector: if you ever want to build this connector, unless you have the dedicated crimper (M22520/2-01) (685\u20ac) (which you can ask to proM), do not attempt to crimp the pins (3\u20ac each), my advice is to solder the cable inside, it is much more resistant than a bad crimp, which is what you\u2019ll get if you take a piler and start squeezing the pin :) LV CAN pinout: 1 - 12V Supply 2 - Empty 3 - GND 4 - empty 5 - CAN H 6 - CAN L 7 - empty 8 - empty The other connector is much easier to work with. SD IMD BMS pinout: 6 - from TSMS 7 - to TSMS 8 - BMS LED 9 - IMD LED 10 - COCKPIT LED 11 - FROM SD 12 - RESET The mapping between the Amphenol connector and the others is self-explanatory,I\u2019m not going to talk about it. The shutdown circuit The shutdown circuit is generated from the PSU, then it passes through the mushroom, to a relay which is controlled by the rasp, then TO_CHARGER, which is the interlock of the connector of the brusa, and then FROM_CHARGER to BMS\u2019s SD, then out of the BMS, to the TSMS key, then in to the BMS again to the airs. Note that the PON (Power ON) of the BRUSA is powered from the shutdown circuit, this way, if the shutdown is opened, the BRUSA is instantaneously disabled. Handcart PCB BRUSA NLG5 Charger deep dive The brusa can be controlled using CAN or can be programmed to be used without the CAN. For our purposes we will control it over CAN BUS. Serial connection To connect with brusa both for debug and/or change the settings we can use the serial interface. To do so, you have to have an USB to serial adapter, connected to the pins of the BRUSA's connector, check the brusa manual. There are specific settings to set up the serial connection, in german they're called anschlusseinstellungen: Baudrate: 19200 Data bits: 8 parity: none stopbits: 1 protocol: Xon/Xoff If you are on windows, let the serial COM settings as default, but edit the putty settings, i got some problems otherwise. Very important : i don't know why, but if you are going to use ChargeStar software you need to change the COM port to COM1, otherwise the brusa will not be recognized by the program. Note that the serial works only if the board on the brusa is fed with 12 volts via the proper pin 2 AUX or with the main power. to use the serial monitor you have to properly connect and setup the serial, then, use putty on windows or minicom on linux to connect to it. You will asked with a pasword, which is \"monitor\" ChargeStar software With the ChargeStar software you can program a charging profile, set various parameters and change some configuration of the brusa, see the brusa's manual for all the infos. Via ChargeStar you can also set the mode to CAN, very useful to control the charge via can. The ChargeStar software will run only on Windows XP or Windows Vista, obviously we'll chose XP, you can run a virtual machine on virtualbox and do the USB-passthrough of the serial to USB adapter. I read that somebody had issues with ChargeStar using the 64 bit version of windows, but for me worked fine. Note that i ran in some problems uploading a custom setting to the brusa: sometimes when the settings are uploaded, the brusa gives an NVSRAM CRC error, the only possible fix is reupload the settings to brusa changing some parameters a bit. I'm still not sure which parameter is causing problems, so change them randomly a bit and it should work after some tries. If you see, some input fields don't accept values with the \".\" not sure why. Connecting by CAN Connecting with CAN allows to monitor the message outputed by the brusa and (if properly configured) to set some parameters for charging. The CAN connection has to end with a 120 Ohm resistor, otherwise the messages will keep bouncing (kinda), trust me, it is necessary. See the full CAN matrix in the manual. By default the CAN is at 500kbps, unless differently specified in config file with ChargeStar. As i saw, brusa send messages just when the PON pin is set to HIGH (>5V). To set and enable the charge via can you have to send periodically a can message named NLG5_CTL see details on the can matrix. Note that the endianess is big (motorola). Setup procedure First, you need to know what you\u2019re doing, you\u2019re going to work with High Voltage both AC and DC, that\u2019s no joke. Finding a good power source Brusa will be absorbing a maximum of 16A on a 230V AC 50Hz outlet, so a maximum of 3.6kW, if you\u2019re using the tripolar connector there shouldn\u2019t be any problem, otherwise if you\u2019re using the tripolar to standard socket adaptor, make sure to check if the line is properly supporting the load. Usually it would just warm up the cables, but if you\u2019re unlucky this could cause a fire, so BE CAREFUL. Note that it is possible to specify to the BRUSA how buc current to absorb. Connecting the accumulator Depending on the accumulator (Chimera or Fenice) you have to choose the right cable. Turn off the TSMS key Turn off the PON switch Connect the accumulator and the brusa with the HV connector. With chimera make sure that it makes a good contact, sometimes the interlock will not be closed properly. Connect the two LV connectors to the accumulator, and the other end to the handcart. Connecting brusa to 220 Once a good power source has been found, connect the brusa to it. You\u2019ll hear a \u201cclick\u201d from the BRUSA. Charge procedure Make sure that just the people needed are near the handcart, the presence of an ESO would be ideal in a not official environment, and required in a race environment. Turn ONthe TSMS key. From now on, the system could be at >400 DC volt. Turn ON the PON. Start the charging software, and then, start the charge. In case of any problem, push the red shutdown button in the handcart, this will stop the charge and close the AIRs of the accumulator. Backup (Emergency) software Before starting, follow the set up procedure for the handcart. It is necessary to initialize the canbus on the raspberry pi, just execute this script. If you need the handcart working as fast as possible, just download the charge script from github, and execute it on the raspberry pi, you will be guided through the precharge process of the accumulator and the charge settings. !!! Warning : This software is DUMB, if you set a voltage, the brusa will deliver it, be careful!. !!! Warning: at the time of writing (18/09/2021) the script supports just chimera\u2019s accumulator, this can be bypassed by reading the next note. !!! Tip: if you need to bypass the precharge check of the accumulator for any reason, you can set the variable \u201cBYPASS_TS_CHECK\u201d in the script to false, this way the script will not check the presence of the accumulator, and the brusa will work on anything it is attached to. Resources & Useful links here you can find BRUSA's CAN messages For pork's can messages search on other E-Agle's repo Fake pointers in python Python threading API Bootstrap dashboard template JS Charts Rasp config Charge state machine of BMS Diagram links https://lucid.app/lucidchart/invitations/accept/dbc53a3d-c901-4d6a-a692-972de6713d43 https://www.raspberrypi.org/documentation/hardware/raspberrypi/spi/README.md","title":"Handcart Documentation"},{"location":"handcart-sw/main/#handcart-documentation","text":"","title":"Handcart Documentation"},{"location":"handcart-sw/main/#index","text":"Structure Resources & Useful links","title":"Index"},{"location":"handcart-sw/main/#intro","text":"The handcart is the device that is responsible of transporting and charging the car's accumulator. It is based on three main components: Brusa NLG513 charger, that is the actual charger Raspberry pi 4 to run the software High Voltage Accumulator The rasp is connected via CAN Bus with the BMS in the accumulator and with the Brusa charger. The software of the handcart is responsible of all the processes to ensure a good and safe charge.","title":"Intro"},{"location":"handcart-sw/main/#abbreviations","text":"BMS, porco, acc -> accumulator HV -> High Voltage rasp -> raspberry FSM -> Finite State Machine TS (on, off) -> Tractive system (HV) (on o off)","title":"Abbreviations"},{"location":"handcart-sw/main/#software","text":"","title":"Software"},{"location":"handcart-sw/main/#overview","text":"The software is written in python and javascript. It's divided in two parts, respectively frontend and backend. The backend is responsible to manage the charge and to communicate with the devices, and it also hosts a webserver for the frontend.","title":"Overview"},{"location":"handcart-sw/main/#backend","text":"The backend is the part of the software that is responsible to manage the charge and to communicate with the devices, it also hosts a webserver to serve pages and data to the frontend. Basically it is a python script that becomes a process, then it splits itself in three threads.","title":"Backend"},{"location":"handcart-sw/main/#threads","text":"The three threads are: The state machine, aka the main thread The flask webserver The CAN read/write process The three threads have an class istance that they can access which is in shared memory, accessed with a lock. Other types of communication are two queues: A queue for can msg send between FSM thread and CAN thread A queue for can msg recv between FSM thread and CAN thread A queue for command send between web server and the FSM","title":"Threads"},{"location":"handcart-sw/main/#main-thread-with-fsm","text":"The FSM is based on multiple states: CHECK: It is a state where the presence of the BMS and the BRUSA are checked, if they are both present it will pass to next state IDLE: Both devices are connected and ready to rock, a precharge command is waited PRECHARGE: Accumulator is asked TS ON, wait until a confirmation is received READY: Accumulator is in TS ON, brusa is ready, waiting for a charge command CHARGE: The charge is enabled C_DONE: The charge is finished ERROR: An error state, the charge (if enabled) is stopped, the BMS is asked to TS OFF, the PON of brusa is set to OFF Note that in each state there's a check over errors from the can, if an error is found, the next state will be ERROR","title":"Main thread with FSM"},{"location":"handcart-sw/main/#statecheck","text":"The presence of BMS and BRUSA is checked, if both are present, goto IDLE","title":"STATE:CHECK"},{"location":"handcart-sw/main/#stateidle","text":"Both devices are connected and ready to rock, a precharge command is waited.","title":"STATE:IDLE"},{"location":"handcart-sw/main/#stateprecharge","text":"A TS ON can message is sent to BMS HV, which will do the precharge. In this state we will check if the bms will finish the precharge. Once it did so, the FSM willl go to READY state.","title":"STATE:PRECHARGE"},{"location":"handcart-sw/main/#stateready","text":"The TS is on, we are waiting to receive the charge command from the webserver. We countinously check the queue for new messages.","title":"STATE:READY"},{"location":"handcart-sw/main/#statecharge","text":"In this state the charge is enabled, to do this, a variable named \"can_forward_enabled\" is set to True. This variable is shared between the FSM trhead and the CAN thread. In the can thread, a check over can_forward_enabled is made, if it's False it will periodically send an empty CAN message to brusa (this is important to keep the link alive, otherwise the brusa will go in an error state if no msgs receivedin 300ms) If it's True, it will send an enable charge command to brusa with the voltage and current settings. For more info check the brusa CAN messages matrix.","title":"STATE:CHARGE"},{"location":"handcart-sw/main/#statec_done","text":"The charge is done, TS is still on, waiting for user input.","title":"STATE:C_DONE"},{"location":"handcart-sw/main/#stateerror","text":"Something triggered an error, we have to turn off everithing that could be dangerous. The method \"staccastacca()\" is called. Where a TS_OFF message both for chimera's and fenice's accumulator is sent. The message is sent until a confirmation about the fact that the TS is OFF is received. In the staccastacca method also the PON is disabled","title":"STATE:ERROR"},{"location":"handcart-sw/main/#the-canread-object","text":"The 'canread' object is an istance of a class that is thought to store all the information of the BMS, BRUSA, CAN and others. It is also used to process all the CAN messages. The CAN thread passes the can messages in the CAN queue and the FSM thread checks for new messages in the queue at each cycle, if so the message is processed in the canread object using a method. The canread object is accessed only by the thread of the FSM, the other threads access a copy of that object that is called shared_data. This is done for safety reason and to assure a fast access without lag to the main thread, as this object contains error state variables.","title":"The canread object"},{"location":"handcart-sw/main/#flask-http-server","text":"This is the server that serve the requests received from the frontend. It uses the shared_data object to retrieve the data from the FSM thread","title":"Flask HTTP server"},{"location":"handcart-sw/main/#frontend","text":"The handcart's frontend is a webapp based on javascript and html, it fetches the data from the backend by doing RESTFUL requests to the backend. Chart are created using amcharts 4 (https://www.amcharts.com/) with Javascript method (NOT the JSON method). To use fetches there are some basic method such as the request-create and the POST method to submit data. I strongly recommend you to use the \"formListener\" method that take a form and the partial URL (because we have to send commands only on the \"/command/\" path, so we can avoid things that can't be done) In forms I create some hidden parameters to identify the command we want to send and it have to correspond with the json parameters shown in the documentation describing the json format.","title":"Frontend"},{"location":"handcart-sw/main/#includeheaderhtml","text":"Is the top-bar that have all status, number of warnings and errors, and actual value for each parameter needed. The error and warning's counter can be clicked to access the respective pages. Every value in the header are calculated by the js/status.js file, which will be loaded on page loading. There's also a big SHUTDOWN button to turn off the charge every time, independently whether page you are.","title":"include/header.html"},{"location":"handcart-sw/main/#indexhtml","text":"This page has six charts: the first on top-left graphically describe the latest voltage values, then you have the charge percentage and the latest current values on the first row. On the second row there are the latest temperature's chart and two charts about cells voltage and temperature that will work only with Fenice (Chimera still don't have these values). Data are received by the flask server using a fetch for each chart to fill the previous data (30 zeros to avoid graphical issues) and then another fetch will be called to ask the server the last data, in order to have a live chart (every 2 seconds).","title":"index.html"},{"location":"handcart-sw/main/#errorhtml-and-warninghtml","text":"These two pages just print BMS-HV and Brusa errors and warnings in a table. The creating-table method is inside the js/tables.js file and look at the json's parameters to create the table. If you need to print a json with the \"title-parameter\" in one column instead of on a row, follow the method used in brusa-info.html.","title":"error.html and warning.html"},{"location":"handcart-sw/main/#brusa-infohtml","text":"In this page are displayed some Brusa's flags in a table made as described above.","title":"brusa-info.html"},{"location":"handcart-sw/main/#settingshtml","text":"Here you can modify some parameters, for example the Cut-Off voltage, the maximum current outlet and a button to enable or disable the fastcharge.","title":"settings.html"},{"location":"handcart-sw/main/#charthtml","text":"This page can actually display \"more pages\": it depends on the parameter passed using the GET method. This parameter is used to set a title in the page and to decide which chart you want to display. At this point it will automatically check which chart-function it has to call and calls also the functions to update the header's values. Those charts won't refresh automatically: you have to refresh the page to see all new data, so you can use the zoom (by clicking in the start position and drag until the end position of the zoom). To seeing all values about a specific chart there is a function called \"createMultilineChart\" that will create a chart with many lines as parameters that are in the json (timestamp excluded).","title":"chart.html"},{"location":"handcart-sw/main/#chart-functions","text":"In addition to chart's creating functions there are some utilities functions in \"/chart/chartsFun.js\": most of them are in this file just to clear the main one and to reuse them if needed, however they contain the more logical part (i.e. how to set the correct color using a percentage or how to set the correct position of each cell value according to the real position - check the image below to understand it better).","title":"Chart functions"},{"location":"handcart-sw/main/#raspberry-configuration","text":"Follow the guide here Rasp config . The password of the raspberry is \"handcartpi\". In the handcart just one CAN bus is necessary.","title":"Raspberry configuration"},{"location":"handcart-sw/main/#hardware","text":"","title":"Hardware"},{"location":"handcart-sw/main/#electrical-wiring","text":"","title":"Electrical wiring"},{"location":"handcart-sw/main/#modular-cables-for-accumulator-connection","text":"I decided to create two modular cables that have a common connector handcart-side, but different connectors at accumulator-side, in a way that we are able to easily switch the connectors between the two accumulators. Both cables connect to the handcart via an Amphenol AT06-12SX1 connector, having these pin mapping: 1 - 12V Supply 2 - 5V Supply (only chimera) 3 - CAN H 4 - TSMS 5 - RESET 6 - IMD LED 7 - Cockpit LED 8 - BMS LED 9 - TO TSMS 10 - CAN L 11 - SD 12 - GND","title":"Modular cables for Accumulator connection"},{"location":"handcart-sw/main/#chimera-evoluzione-accumulator-cable","text":"To the other side of the cable we have two connectors, LV-CAN and SD IMD BMS. They use the same connectors used for chimera\u2019s CAN. LV-CAN pin mapping: 1 - RESET 2 - BMS LED 3 - empty 4 - TO TSMS 5 - SD 6 - empty 7 - IMD 8 - TSMS SD IMD BMS pin mapping: As chimera can connectors standard","title":"Chimera Evoluzione accumulator cable"},{"location":"handcart-sw/main/#fenice-accumulator-cable","text":"As for chimera it has two connectors to the other end of the cable, this time, the connectors are TE 776273-1 for SD IMD BMS and CeeLok FAS-T for LV CAN. Tip Tip for the CeeLok FAS-T connector: if you ever want to build this connector, unless you have the dedicated crimper (M22520/2-01) (685\u20ac) (which you can ask to proM), do not attempt to crimp the pins (3\u20ac each), my advice is to solder the cable inside, it is much more resistant than a bad crimp, which is what you\u2019ll get if you take a piler and start squeezing the pin :) LV CAN pinout: 1 - 12V Supply 2 - Empty 3 - GND 4 - empty 5 - CAN H 6 - CAN L 7 - empty 8 - empty The other connector is much easier to work with. SD IMD BMS pinout: 6 - from TSMS 7 - to TSMS 8 - BMS LED 9 - IMD LED 10 - COCKPIT LED 11 - FROM SD 12 - RESET The mapping between the Amphenol connector and the others is self-explanatory,I\u2019m not going to talk about it.","title":"Fenice accumulator cable"},{"location":"handcart-sw/main/#the-shutdown-circuit","text":"The shutdown circuit is generated from the PSU, then it passes through the mushroom, to a relay which is controlled by the rasp, then TO_CHARGER, which is the interlock of the connector of the brusa, and then FROM_CHARGER to BMS\u2019s SD, then out of the BMS, to the TSMS key, then in to the BMS again to the airs. Note that the PON (Power ON) of the BRUSA is powered from the shutdown circuit, this way, if the shutdown is opened, the BRUSA is instantaneously disabled.","title":"The shutdown circuit"},{"location":"handcart-sw/main/#handcart-pcb","text":"","title":"Handcart PCB"},{"location":"handcart-sw/main/#brusa-nlg5-charger-deep-dive","text":"The brusa can be controlled using CAN or can be programmed to be used without the CAN. For our purposes we will control it over CAN BUS.","title":"BRUSA NLG5 Charger deep dive"},{"location":"handcart-sw/main/#serial-connection","text":"To connect with brusa both for debug and/or change the settings we can use the serial interface. To do so, you have to have an USB to serial adapter, connected to the pins of the BRUSA's connector, check the brusa manual. There are specific settings to set up the serial connection, in german they're called anschlusseinstellungen: Baudrate: 19200 Data bits: 8 parity: none stopbits: 1 protocol: Xon/Xoff If you are on windows, let the serial COM settings as default, but edit the putty settings, i got some problems otherwise. Very important : i don't know why, but if you are going to use ChargeStar software you need to change the COM port to COM1, otherwise the brusa will not be recognized by the program. Note that the serial works only if the board on the brusa is fed with 12 volts via the proper pin 2 AUX or with the main power. to use the serial monitor you have to properly connect and setup the serial, then, use putty on windows or minicom on linux to connect to it. You will asked with a pasword, which is \"monitor\"","title":"Serial connection"},{"location":"handcart-sw/main/#chargestar-software","text":"With the ChargeStar software you can program a charging profile, set various parameters and change some configuration of the brusa, see the brusa's manual for all the infos. Via ChargeStar you can also set the mode to CAN, very useful to control the charge via can. The ChargeStar software will run only on Windows XP or Windows Vista, obviously we'll chose XP, you can run a virtual machine on virtualbox and do the USB-passthrough of the serial to USB adapter. I read that somebody had issues with ChargeStar using the 64 bit version of windows, but for me worked fine. Note that i ran in some problems uploading a custom setting to the brusa: sometimes when the settings are uploaded, the brusa gives an NVSRAM CRC error, the only possible fix is reupload the settings to brusa changing some parameters a bit. I'm still not sure which parameter is causing problems, so change them randomly a bit and it should work after some tries. If you see, some input fields don't accept values with the \".\" not sure why.","title":"ChargeStar software"},{"location":"handcart-sw/main/#connecting-by-can","text":"Connecting with CAN allows to monitor the message outputed by the brusa and (if properly configured) to set some parameters for charging. The CAN connection has to end with a 120 Ohm resistor, otherwise the messages will keep bouncing (kinda), trust me, it is necessary. See the full CAN matrix in the manual. By default the CAN is at 500kbps, unless differently specified in config file with ChargeStar. As i saw, brusa send messages just when the PON pin is set to HIGH (>5V). To set and enable the charge via can you have to send periodically a can message named NLG5_CTL see details on the can matrix. Note that the endianess is big (motorola).","title":"Connecting by CAN"},{"location":"handcart-sw/main/#setup-procedure","text":"First, you need to know what you\u2019re doing, you\u2019re going to work with High Voltage both AC and DC, that\u2019s no joke.","title":"Setup procedure"},{"location":"handcart-sw/main/#finding-a-good-power-source","text":"Brusa will be absorbing a maximum of 16A on a 230V AC 50Hz outlet, so a maximum of 3.6kW, if you\u2019re using the tripolar connector there shouldn\u2019t be any problem, otherwise if you\u2019re using the tripolar to standard socket adaptor, make sure to check if the line is properly supporting the load. Usually it would just warm up the cables, but if you\u2019re unlucky this could cause a fire, so BE CAREFUL. Note that it is possible to specify to the BRUSA how buc current to absorb.","title":"Finding a good power source"},{"location":"handcart-sw/main/#connecting-the-accumulator","text":"Depending on the accumulator (Chimera or Fenice) you have to choose the right cable. Turn off the TSMS key Turn off the PON switch Connect the accumulator and the brusa with the HV connector. With chimera make sure that it makes a good contact, sometimes the interlock will not be closed properly. Connect the two LV connectors to the accumulator, and the other end to the handcart.","title":"Connecting the accumulator"},{"location":"handcart-sw/main/#connecting-brusa-to-220","text":"Once a good power source has been found, connect the brusa to it. You\u2019ll hear a \u201cclick\u201d from the BRUSA.","title":"Connecting brusa to 220"},{"location":"handcart-sw/main/#charge-procedure","text":"Make sure that just the people needed are near the handcart, the presence of an ESO would be ideal in a not official environment, and required in a race environment. Turn ONthe TSMS key. From now on, the system could be at >400 DC volt. Turn ON the PON. Start the charging software, and then, start the charge. In case of any problem, push the red shutdown button in the handcart, this will stop the charge and close the AIRs of the accumulator.","title":"Charge procedure"},{"location":"handcart-sw/main/#backup-emergency-software","text":"Before starting, follow the set up procedure for the handcart. It is necessary to initialize the canbus on the raspberry pi, just execute this script. If you need the handcart working as fast as possible, just download the charge script from github, and execute it on the raspberry pi, you will be guided through the precharge process of the accumulator and the charge settings. !!! Warning : This software is DUMB, if you set a voltage, the brusa will deliver it, be careful!. !!! Warning: at the time of writing (18/09/2021) the script supports just chimera\u2019s accumulator, this can be bypassed by reading the next note. !!! Tip: if you need to bypass the precharge check of the accumulator for any reason, you can set the variable \u201cBYPASS_TS_CHECK\u201d in the script to false, this way the script will not check the presence of the accumulator, and the brusa will work on anything it is attached to.","title":"Backup (Emergency) software"},{"location":"handcart-sw/main/#resources-useful-links","text":"here you can find BRUSA's CAN messages For pork's can messages search on other E-Agle's repo Fake pointers in python Python threading API Bootstrap dashboard template JS Charts Rasp config Charge state machine of BMS","title":"Resources &amp; Useful links"},{"location":"handcart-sw/main/#diagram-links","text":"https://lucid.app/lucidchart/invitations/accept/dbc53a3d-c901-4d6a-a692-972de6713d43 https://www.raspberrypi.org/documentation/hardware/raspberrypi/spi/README.md","title":"Diagram links"}]}